{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"autoware.core","text":""},{"location":"#autowarecore","title":"autoware.core","text":"<ul> <li>An Autoware repository that contains a basic set of high-quality, stable ROS packages for autonomous driving.</li> </ul> <ul> <li>Although this repository is currently empty, porting of code from Universe to Core will begin once the interfaces for Autoware Core/Universe have been finalized, as per ongoing Autoware Architecture WG discussions.</li> <li>A more detailed explanation about Autoware Core can be found on the Autoware concepts documentation page.</li> </ul> <ul> <li>For researchers and developers who want to extend the functionality of Autoware Core with experimental, cutting-edge ROS packages, see Autoware Universe.</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at conduct@autoware.org. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#contributing","title":"Contributing","text":"<p>See https://autowarefoundation.github.io/autoware-documentation/main/contributing/.</p>"},{"location":"DISCLAIMER/","title":"DISCLAIMER","text":"<p>DISCLAIMER</p> <p>\u201cAutoware\u201d will be provided by The Autoware Foundation under the Apache License 2.0. This \u201cDISCLAIMER\u201d will be applied to all users of Autoware (a \u201cUser\u201d or \u201cUsers\u201d) with the Apache License 2.0 and Users shall hereby approve and acknowledge all the contents specified in this disclaimer below and will be deemed to consent to this disclaimer without any objection upon utilizing or downloading Autoware.</p> <p>Disclaimer and Waiver of Warranties</p> <ol> <li> <p>AUTOWARE FOUNDATION MAKES NO REPRESENTATION OR WARRANTY OF ANY KIND,    EXPRESS OR IMPLIED, WITH RESPECT TO PROVIDING AUTOWARE (the \u201cService\u201d)    including but not limited to any representation or warranty (i) of fitness or    suitability for a particular purpose contemplated by the Users, (ii) of the    expected functions, commercial value, accuracy, or usefulness of the Service,    (iii) that the use by the Users of the Service complies with the laws and    regulations applicable to the Users or any internal rules established by    industrial organizations, (iv) that the Service will be free of interruption or    defects, (v) of the non-infringement of any third party's right and (vi) the    accuracy of the content of the Services and the software itself.</p> </li> <li> <p>The Autoware Foundation shall not be liable for any damage incurred by the    User that are attributable to the Autoware Foundation for any reasons    whatsoever. UNDER NO CIRCUMSTANCES SHALL THE AUTOWARE FOUNDATION BE LIABLE FOR    INCIDENTAL, INDIRECT, SPECIAL OR FUTURE DAMAGES OR LOSS OF PROFITS.</p> </li> <li> <p>A User shall be entirely responsible for the content posted by the User and    its use of any content of the Service or the Website. If the User is held    responsible in a civil action such as a claim for damages or even in a criminal    case, the Autoware Foundation and member companies, governments and academic &amp;    non-profit organizations and their directors, officers, employees and agents    (collectively, the \u201cIndemnified Parties\u201d) shall be completely discharged from    any rights or assertions the User may have against the Indemnified Parties, or    from any legal action, litigation or similar procedures.</p> </li> </ol> <p>Indemnity</p> <p>A User shall indemnify and hold the Indemnified Parties harmless from any of their damages, losses, liabilities, costs or expenses (including attorneys' fees or criminal compensation), or any claims or demands made against the Indemnified Parties by any third party, due to or arising out of, or in connection with utilizing Autoware (including the representations and warranties), the violation of applicable Product Liability Law of each country (including criminal case) or violation of any applicable laws by the Users, or the content posted by the User or its use of any content of the Service or the Website.</p>"},{"location":"common/autoware_component_interface_specs/","title":"autoware_component_interface_specs","text":""},{"location":"common/autoware_component_interface_specs/#autoware_component_interface_specs","title":"autoware_component_interface_specs","text":"<p>This package defines the standardized component interface specifications for Autoware Core, ensuring consistent communication and interaction between various components in the Autoware autonomous driving stack.</p>"},{"location":"common/autoware_component_interface_specs/#purpose","title":"Purpose","text":"<p>The purpose of this package is to:</p> <ul> <li>Provide a single source of truth for component interface definitions</li> <li>Ensure consistency across different implementations</li> <li>Facilitate modular development and component interchangeability</li> <li>Document the communication protocols between Autoware Core components</li> </ul>"},{"location":"common/autoware_component_interface_specs/#structure","title":"Structure","text":"<p>The package contains interface specifications for various components, including:</p> <ul> <li>Message definitions</li> <li>Service interfaces</li> <li>Action interfaces</li> </ul>"},{"location":"common/autoware_component_interface_specs/#usage","title":"Usage","text":"<p>To use these interface specifications in your component:</p> <ol> <li> <p>Add this package as a dependency in your package.xml:</p> <pre><code>&lt;depend&gt;autoware_component_interface_specs&lt;/depend&gt;\n</code></pre> </li> <li> <p>Use the provided interfaces in your component code.</p> <pre><code>#include &lt;autoware/component_interface_specs/localization.hpp&gt;\n// Example: Creating a publisher using the interface specs\nusing KinematicState = autoware::component_interface_specs::localization::KinematicState;\nrclcpp::Publisher&lt;KinematicState::Message&gt;::SharedPtr publisher_ =\ncreate_publisher&lt;KinematicState::Message&gt;(\nKinematicState::name,\nautoware::component_interface_specs::get_qos(KinematicState));\n// Example: Creating a subscription using the interface specs\nauto subscriber_ = create_subscription&lt;KinematicState::Message&gt;(\nKinematicState::name,\nautoware::component_interface_specs::get_qos(KinematicState),\nstd::bind(&amp;YourClass::callback, this, std::placeholders::1));\n</code></pre> </li> </ol>"},{"location":"common/autoware_geography_utils/","title":"autoware_geography_utils","text":""},{"location":"common/autoware_geography_utils/#autoware_geography_utils","title":"autoware_geography_utils","text":""},{"location":"common/autoware_geography_utils/#purpose","title":"Purpose","text":"<p>This package contains geography-related utility functions used by other Autoware packages. It provides functionality for geographic coordinate transformations, height calculations, and Lanelet2 map projections.</p>"},{"location":"common/autoware_interpolation/","title":"Interpolation package","text":""},{"location":"common/autoware_interpolation/#interpolation-package","title":"Interpolation package","text":"<p>This package supplies linear and spline interpolation functions.</p>"},{"location":"common/autoware_interpolation/#linear-interpolation","title":"Linear Interpolation","text":"<p><code>lerp(src_val, dst_val, ratio)</code> (for scalar interpolation) interpolates <code>src_val</code> and <code>dst_val</code> with <code>ratio</code>. This will be replaced with <code>std::lerp(src_val, dst_val, ratio)</code> in <code>C++20</code>.</p> <p><code>lerp(base_keys, base_values, query_keys)</code> (for vector interpolation) applies linear regression to each two continuous points whose x values are<code>base_keys</code> and whose y values are <code>base_values</code>. Then it calculates interpolated values on y-axis for <code>query_keys</code> on x-axis.</p>"},{"location":"common/autoware_interpolation/#spline-interpolation","title":"Spline Interpolation","text":"<p><code>spline(base_keys, base_values, query_keys)</code> (for vector interpolation) applies spline regression to each two continuous points whose x values are<code>base_keys</code> and whose y values are <code>base_values</code>. Then it calculates interpolated values on y-axis for <code>query_keys</code> on x-axis.</p>"},{"location":"common/autoware_interpolation/#evaluation-of-calculation-cost","title":"Evaluation of calculation cost","text":"<p>We evaluated calculation cost of spline interpolation for 100 points, and adopted the best one which is tridiagonal matrix algorithm. Methods except for tridiagonal matrix algorithm exists in <code>spline_interpolation</code> package, which has been removed from Autoware.</p> Method Calculation time Tridiagonal Matrix Algorithm 0.007 [ms] Preconditioned Conjugate Gradient 0.024 [ms] Successive Over-Relaxation 0.074 [ms]"},{"location":"common/autoware_interpolation/#spline-interpolation-algorithm","title":"Spline Interpolation Algorithm","text":"<p>Assuming that the size of <code>base_keys</code> (\\(x_i\\)) and <code>base_values</code> (\\(y_i\\)) are \\(N + 1\\), we aim to calculate spline interpolation with the following equation to interpolate between \\(y_i\\) and \\(y_{i+1}\\).</p> \\[ Y_i(x) = a_i (x - x_i)^3 + b_i (x - x_i)^2 + c_i (x - x_i) + d_i \\ \\ \\ (i = 0, \\dots, N-1) \\] <p>Constraints on spline interpolation are as follows. The number of constraints is \\(4N\\), which is equal to the number of variables of spline interpolation.</p> \\[ \\begin{align} Y_i (x_i) &amp; = y_i \\ \\ \\ (i = 0, \\dots, N-1) \\\\ Y_i (x_{i+1}) &amp; = y_{i+1} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ Y_i '(x_{i+1}) &amp; = Y_{i+1}' (x_{i+1}) \\ \\ \\ (i = 0, \\dots, N-2) \\\\ Y_i (x_{i+1})'' &amp; = Y_{i+1}'' (x_{i+1}) \\ \\ \\ (i = 0, \\dots, N-2) \\\\ Y_0 ''(x_0) &amp; = 0 \\\\ Y_{N-1}'' (x_N) &amp; = 0 \\end{align} \\] <p>According to this article, spline interpolation is formulated as the following linear equation.</p> \\[ \\begin{align}  \\begin{pmatrix}     2(h_0 + h_1) &amp; h_1 \\\\     h_0 &amp; 2 (h_1 + h_2) &amp; h_2 &amp; &amp; O \\\\         &amp;     &amp;     &amp; \\ddots \\\\     O &amp;     &amp;     &amp;       &amp; h_{N-2} &amp; 2 (h_{N-2} + h_{N-1})  \\end{pmatrix}  \\begin{pmatrix}     v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_{N-1}  \\end{pmatrix}=  \\begin{pmatrix}     w_1 \\\\ w_2 \\\\ w_3 \\\\ \\vdots \\\\ w_{N-1}  \\end{pmatrix} \\end{align} \\] <p>where</p> \\[ \\begin{align} h_i &amp; = x_{i+1} - x_i \\ \\ \\ (i = 0, \\dots, N-1) \\\\ w_i &amp; = 6 \\left(\\frac{y_{i+1} - y_{i+1}}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}}\\right) \\ \\ \\ (i = 1, \\dots, N-1) \\end{align} \\] <p>The coefficient matrix of this linear equation is tridiagonal matrix. Therefore, it can be solve with tridiagonal matrix algorithm, which can solve linear equations without gradient descent methods.</p> <p>Solving this linear equation with tridiagonal matrix algorithm, we can calculate coefficients of spline interpolation as follows.</p> \\[ \\begin{align} a_i &amp; = \\frac{v_{i+1} - v_i}{6 (x_{i+1} - x_i)} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ b_i &amp; = \\frac{v_i}{2} \\ \\ \\ (i = 0, \\dots, N-1) \\\\ c_i &amp; = \\frac{y_{i+1} - y_i}{x_{i+1} - x_i} - \\frac{1}{6}(x_{i+1} - x_i)(2 v_i + v_{i+1}) \\ \\ \\ (i = 0, \\dots, N-1) \\\\ d_i &amp; = y_i \\ \\ \\ (i = 0, \\dots, N-1) \\end{align} \\]"},{"location":"common/autoware_interpolation/#tridiagonal-matrix-algorithm","title":"Tridiagonal Matrix Algorithm","text":"<p>We solve tridiagonal linear equation according to this article where variables of linear equation are expressed as follows in the implementation.</p> \\[ \\begin{align}  \\begin{pmatrix}     b_0 &amp; c_0 &amp;     &amp; \\\\     a_0 &amp; b_1 &amp; c_2 &amp; O \\\\         &amp;     &amp; \\ddots \\\\     O &amp;     &amp; a_{N-2} &amp;  b_{N-1}  \\end{pmatrix} x = \\begin{pmatrix}     d_0 \\\\ d_2 \\\\ d_3 \\\\ \\vdots \\\\ d_{N-1}  \\end{pmatrix} \\end{align} \\]"},{"location":"common/autoware_kalman_filter/","title":"kalman_filter","text":""},{"location":"common/autoware_kalman_filter/#kalman_filter","title":"kalman_filter","text":""},{"location":"common/autoware_kalman_filter/#overview","title":"Overview","text":"<p>This package contains the kalman filter with time delay and the calculation of the kalman filter.</p>"},{"location":"common/autoware_kalman_filter/#design","title":"Design","text":"<p>The Kalman filter is a recursive algorithm used to estimate the state of a dynamic system. The Time Delay Kalman filter is based on the standard Kalman filter and takes into account possible time delays in the measured values.</p>"},{"location":"common/autoware_kalman_filter/#standard-kalman-filter","title":"Standard Kalman Filter","text":""},{"location":"common/autoware_kalman_filter/#system-model","title":"System Model","text":"<p>Assume that the system can be represented by the following linear discrete model:</p> \\[ x_{k} = A x_{k-1} + B u_{k} \\\\ y_{k} = C x_{k-1} \\] <p>where,</p> <ul> <li>\\(x_k\\) is the state vector at time \\(k\\).</li> <li>\\(u_k\\) is the control input vector at time \\(k\\).</li> <li>\\(y_k\\) is the measurement vector at time \\(k\\).</li> <li>\\(A\\) is the state transition matrix.</li> <li>\\(B\\) is the control input matrix.</li> <li>\\(C\\) is the measurement matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#prediction-step","title":"Prediction Step","text":"<p>The prediction step consists of updating the state and covariance matrices:</p> \\[ x_{k|k-1} = A x_{k-1|k-1} + B u_{k} \\\\ P_{k|k-1} = A P_{k-1|k-1} A^{T} + Q \\] <p>where,</p> <ul> <li>\\(x_{k|k-1}\\) is the priori state estimate.</li> <li>\\(P_{k|k-1}\\) is the priori covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#update-step","title":"Update Step","text":"<p>When the measurement value \\( y_k \\) is received, the update steps are as follows:</p> \\[ K_k = P_{k|k-1} C^{T} (C P_{k|k-1} C^{T} + R)^{-1} \\\\ x_{k|k} = x_{k|k-1} + K_k (y_{k} - C x_{k|k-1}) \\\\ P_{k|k} = (I - K_k C) P_{k|k-1} \\] <p>where,</p> <ul> <li>\\(K_k\\) is the Kalman gain.</li> <li>\\(x_{k|k}\\) is the posterior state estimate.</li> <li>\\(P_{k|k}\\) is the posterior covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#extension-to-time-delay-kalman-filter","title":"Extension to Time Delay Kalman Filter","text":"<p>For the Time Delay Kalman filter, it is assumed that there may be a maximum delay of step (\\(d\\)) in the measured value. To handle this delay, we extend the state vector to:</p> \\[ (x_{k})_e = \\begin{bmatrix} x_k \\\\ x_{k-1} \\\\ \\vdots \\\\ x_{k-d+1} \\end{bmatrix} \\] <p>The corresponding state transition matrix (\\(A_e\\)) and process noise covariance matrix (\\(Q_e\\)) are also expanded:</p> \\[ A_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix}, \\quad Q_e = \\begin{bmatrix} Q &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\]"},{"location":"common/autoware_kalman_filter/#prediction-step_1","title":"Prediction Step","text":"<p>The prediction step consists of updating the extended state and covariance matrices.</p> <p>Update extension status:</p> \\[ (x_{k|k-1})_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\begin{bmatrix} x_{k-1|k-1} \\\\ x_{k-2|k-1} \\\\ \\vdots \\\\ x_{k-d|k-1} \\end{bmatrix} \\] <p>Update extended covariance matrix:</p> \\[ (P_{k|k-1})_e = \\begin{bmatrix} A &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ I &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{bmatrix} \\begin{bmatrix} P_{k-1|k-1}^{(1)} &amp; P_{k-1|k-1}^{(1,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(1,d)} \\\\ P_{k-1|k-1}^{(2,1)} &amp; P_{k-1|k-1}^{(2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(2,d)} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ P_{k-1|k-1}^{(d,1)} &amp; P_{k-1|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(d)} \\end{bmatrix} \\begin{bmatrix}  A^T &amp; I &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; I &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0  \\end{bmatrix} +  \\begin{bmatrix}  Q &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\  \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0  \\end{bmatrix} \\] <p>\\(\\Longrightarrow\\)</p> \\[ (P_{k|k-1})_e = \\begin{bmatrix} A P_{k-1|k-1}^{(1)} A^T + Q &amp; A P_{k-1|k-1}^{(1,2)} &amp; \\cdots &amp; A P_{k-1|k-1}^{(1,d)} \\\\ P_{k-1|k-1}^{(2,1)} A^T &amp; P_{k-1|k-1}^{(2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(2,d)} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ P_{k-1|k-1}^{(d,1)} A^T &amp; P_{k-1|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k-1|k-1}^{(d)} \\end{bmatrix} \\] <p>where,</p> <ul> <li>\\((x_{k|k-1})_e\\) is the priori extended state estimate.</li> <li>\\((P_{k|k-1})_e\\) is the priori extended covariance matrix.</li> </ul>"},{"location":"common/autoware_kalman_filter/#update-step_1","title":"Update Step","text":"<p>When receiving the measurement value ( \\(y_{k}\\) ) with a delay of ( \\(ds\\) ), the update steps are as follows:</p> <p>Update kalman gain:</p> \\[ K_k = \\begin{bmatrix} P_{k|k-1}^{(1)} C^T \\\\ P_{k|k-1}^{(2)} C^T \\\\ \\vdots \\\\ P_{k|k-1}^{(ds)} C^T \\\\ \\vdots \\\\ P_{k|k-1}^{(d)} C^T \\end{bmatrix} (C P_{k|k-1}^{(ds)} C^T + R)^{-1} \\] <p>Update extension status:</p> \\[ (x_{k|k})_e = \\begin{bmatrix} x_{k|k-1} \\\\ x_{k-1|k-1} \\\\ \\vdots \\\\ x_{k-d+1|k-1} \\end{bmatrix} + \\begin{bmatrix} K_k^{(1)} \\\\ K_k^{(2)} \\\\ \\vdots \\\\ K_k^{(ds)} \\\\ \\vdots \\\\ K_k^{(d)} \\end{bmatrix} (y_k - C x_{k-ds|k-1}) \\] <p>Update extended covariance matrix:</p> \\[  (P_{k|k})_e = \\left(I -  \\begin{bmatrix}  K_k^{(1)} C \\\\  K_k^{(2)} C \\\\  \\vdots \\\\  K_k^{(ds)} C \\\\  \\vdots \\\\  K_k^{(d)} C  \\end{bmatrix}\\right)  \\begin{bmatrix}  P_{k|k-1}^{(1)} &amp; P_{k|k-1}^{(1,2)} &amp; \\cdots &amp; P_{k|k-1}^{(1,d)} \\\\  P_{k|k-1}^{(2,1)} &amp; P_{k|k-1}^{(2)} &amp; \\cdots &amp; P_{k|k-1}^{(2,d)} \\\\  \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  P_{k|k-1}^{(d,1)} &amp; P_{k|k-1}^{(d,2)} &amp; \\cdots &amp; P_{k|k-1}^{(d)}  \\end{bmatrix} \\] <p>where,</p> <ul> <li>\\(K_k\\) is the Kalman gain.</li> <li>\\((x_{k|k})_e\\) is the posterior extended state estimate.</li> <li>\\((P_{k|k})_e\\) is the posterior extended covariance matrix.</li> <li>\\(C\\) is the measurement matrix, which only applies to the delayed state part.</li> </ul>"},{"location":"common/autoware_kalman_filter/#example-usage","title":"Example Usage","text":"<p>This section describes Example Usage of KalmanFilter.</p> <ul> <li>Initialization</li> </ul> <pre><code>#include \"autoware/kalman_filter/kalman_filter.hpp\"\n\n// Define system parameters\nint dim_x = 2; // state vector dimensions\nint dim_y = 1; // measure vector dimensions\n\n// Initial state\nEigen::MatrixXd x0 = Eigen::MatrixXd::Zero(dim_x, 1);\nx0 &lt;&lt; 0.0, 0.0;\n\n// Initial covariance matrix\nEigen::MatrixXd P0 = Eigen::MatrixXd::Identity(dim_x, dim_x);\nP0 *= 100.0;\n\n// Define state transition matrix\nEigen::MatrixXd A = Eigen::MatrixXd::Identity(dim_x, dim_x);\nA(0, 1) = 1.0;\n\n// Define measurement matrix\nEigen::MatrixXd C = Eigen::MatrixXd::Zero(dim_y, dim_x);\nC(0, 0) = 1.0;\n\n// Define process noise covariance matrix\nEigen::MatrixXd Q = Eigen::MatrixXd::Identity(dim_x, dim_x);\nQ *= 0.01;\n\n// Define measurement noise covariance matrix\nEigen::MatrixXd R = Eigen::MatrixXd::Identity(dim_y, dim_y);\nR *= 1.0;\n\n// Initialize Kalman filter\nautoware::kalman_filter::KalmanFilter kf;\nkf.init(x0, P0);\n</code></pre> <ul> <li>Predict step</li> </ul> <pre><code>const Eigen::MatrixXd x_next = A * x0;\nkf.predict(x_next, A, Q);\n</code></pre> <ul> <li>Update step</li> </ul> <pre><code>// Measured value\nEigen::MatrixXd y = Eigen::MatrixXd::Zero(dim_y, 1);\nkf.update(y, C, R);\n</code></pre> <ul> <li>Get the current estimated state and covariance matrix</li> </ul> <pre><code>Eigen::MatrixXd x_curr = kf.getX();\nEigen::MatrixXd P_curr = kf.getP();\n</code></pre>"},{"location":"common/autoware_kalman_filter/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<ul> <li>Delay Step Check: Ensure that the <code>delay_step</code> provided during the update does not exceed the maximum delay steps set during initialization.</li> </ul>"},{"location":"common/autoware_lanelet2_utils/","title":"autoware_lanelet2_utils","text":""},{"location":"common/autoware_lanelet2_utils/#autoware_lanelet2_utils","title":"autoware_lanelet2_utils","text":""},{"location":"common/autoware_lanelet2_utils/#nomenclature","title":"Nomenclature","text":"<p>This package aims to strictly define the meaning of several words to clarify the documentation and API's scope. In the table below, <code>codespace</code> words are given specific meanings when used in the API and API description. italic words are emphasized to indicate that it refers to social common sense which often comes with ambiguity. To help disambiguate the meaning, illustration is provided. \"Lanelet\" refers to the entity of a<code>lanelet::ConstLanelet</code> object in order to distinguish with the word \"lane\" used in social customs. <code>A</code> and <code>B</code> stands for some Lanelets objects.</p> Word Meaning Illustration <code>driving</code> The vehicle position belongs to the designated Lanelet. In each map, green Lanelet are the <code>driving</code> lanes of the vehicle.Open <code>boundary</code>,<code>entry</code>,<code>exit</code> The <code>boundary</code> of a Lanelet refers to the left or right Linestring. Open <code>adjacent</code> If A is <code>adjacent</code> to B, A and B share a common <code>boundary</code> with same direction either on the left or right side. In each map, orange Lanelet is <code>adjacent</code> to green Lanelet.Open <code>same_direction</code> Lanelet A and Lanelet B are <code>same_direction</code> if A and B are directly or indirectly <code>adjacent</code> to each other. In each map, orange Lanelets are <code>same_direction</code> as green Lanelet.Open <code>bundle</code> A <code>bundle</code> refers to a transitive closure set of Lanelets which are <code>same_direction</code> to each other. The enclosed sets of Lanelets are <code>bundle</code>s.Open <code>opposite</code> If A is <code>opposite</code> to B, A and B share a common <code>boundary</code> with opposite direction. In the first map, green Lanelet and orange Lanelet are <code>opposite</code> to each other.In the second map, two red Lanelets are not <code>opposite</code> relation because they do not share a common LineString.Open <code>opposite_direction</code> If A and B are <code>opposite_direction</code>, the <code>bundle</code> of A and B are directly <code>opposite</code> to each other. In the each map, green Lanelet and orange Lanelet are <code>opposite_direction</code> because their <code>bundle</code>s(enclosed in dotted line) are <code>opposite</code> relation.Open <code>connected</code> A is <code>connected</code> to(from) B if and only if the <code>exit</code>(<code>entry</code>) of A is identical to the <code>entry</code>(<code>exit</code>) of B. A is connected to B, and B is connected from A.Open <code>following</code> The <code>following</code> Lanelets of A is the list of Lanelets to which A is <code>connected</code>. In each map, orange Lanelets are the <code>following</code> of green Lanelet.Open <code>previous</code> The <code>previous</code> Lanelets of A is the list of Lanelets from which A is <code>connected</code>. In each map, orange Lanelets are the <code>previous</code> of green Lanelet.  Open <code>conflicting</code> A is <code>conflicting</code> with B if A and B are geometrically intersecting. <code>merging</code> A is said to be <code>merging</code> Lanelet of B if and only if A is <code>conflicting</code> with B and both A and B are connected to a common Lanelet. In each map, one of the orange Lanelet is a <code>merging</code> Lanelet of the other orange Lanelet.Open <code>sibling</code> The designated Lanelets are referred to as <code>sibling</code> if all of them are <code>connected</code> from a common Lanelet. In each map, orange Lanelets are <code>sibling</code>s.Open <code>oncoming</code> TBD TBD <code>upcoming</code> TBD TBD <code>sequence</code> <code>sequence</code> is a list of Lanelets whose each element is <code>connected from</code> or <code>adjacent to</code> the previous element. Open"},{"location":"common/autoware_lanelet2_utils/#api-description","title":"API description","text":"Header function description average computational complexity illustration <code>&lt;autoware_lanelet2_utils/kind.hpp&gt;</code> <code>is_road_lane</code> This function returns <code>true</code> if the input Lanelet is <code>road</code> subtype. \\(O(1)\\) <code>is_shoulder_lane</code> This function returns <code>true</code> if the input Lanelet is <code>road_shoulder</code> subtype. \\(O(1)\\) <code>is_bicycle_lane</code> This function returns <code>true</code> if the input Lanelet is <code>bicycle_lane</code> subtype. \\(O(1)\\) <code>&lt;autoware_lanelet2_utils/topology.hpp&gt;</code> <code>instantiate_routing_graph</code> This function creates a <code>RoutingGraph</code> object only from \"road\" lanes, which means \"road_shoulder\" and \"bicycle_lane\" Lanelets are inaccessible from left/right adjacency. <code>left_lanelet</code> This function ignores the permission of lane change. Also it ignores <code>shoulder</code> and <code>bicycle</code> Lanelet. \\(O(1)\\) In the first map, the green Lanelet is the <code>left_lanelet</code> of the orange Lanelet.In the second and third map, the <code>left_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>right_lanelet</code> same as above <code>left_lanelet</code> \\(O(1)\\) <code>left_opposite_lanelet</code> same as below <code>right_opposite_lanelet</code> \\(O(1)\\)see <code>findUsage</code> for detail <code>right_opposite_lanelet</code> This functions returns the right <code>opposite</code> Lanelet of the input Lanelet if available, otherwise returns null. \\(O(1)\\)see <code>findUsage</code> for detail In the first and second map, the green Lanelet is the <code>right_opposite_lanelet</code> of the orange Lanelet.In the third map, the <code>right_opposite_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>leftmost_lanelet</code> This function returns the Lanelet which is recursively left adjacent to the input Lanelet. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first and second map, the green Lanelet is the <code>leftmost_lanelet</code> of the orange Lanelet.In the third map, the <code>leftmost_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>rightmost_lanelet</code> This function returns the Lanelet which is recursively right adjacent to the input Lanelet. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first map, the green Lanelet is the <code>rightmost_lanelet</code> of the orange Lanelet.In the second and third map, the <code>rightmost_lanelet</code> of the orange Lanelet is <code>null</code>.Open <code>left_lanelets</code> The input Lanelet is not included in the output, and output is ordered from left to right. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle</code>. In the first map, the green Lanelets are the <code>left_lanelets</code> of the orange Lanelet.In the second and third map, <code>left_lanelets</code> of the orange Lanelet is empty.If the flag <code>include_opposite = true</code>, the left opposite Lanelet and all of its <code>same_direction</code> Lanelets area also retrieved as illustrated in the fourth and fifth maps.Open <code>right_lanelets</code> The input Lanelet is not included in the output, and output is ordered from right to left. \\(O(W)\\) where \\(W\\) is the size of the <code>bundle.</code> In the first map, the green Lanelets are the <code>right_lanelets</code> of the orange Lanelet.In the second and third map, <code>right_lanelets</code> of the orange Lanelet is empty.If the flag <code>include_opposite = true</code>, the right opposite Lanelet and all of its <code>same_direction</code> Lanelets area also retrieved as illustrated in the fourth and fifth maps.Open <code>following_lanelets</code> This function returns the <code>following</code> Lanelets of the input Lanelet. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of Lanelets to which the input is connected to. <code>previous_lanelets</code> This function returns the <code>previous</code> Lanelets of the input Lanelet. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of Lanelets from which the input is connected from. <code>sibling_lanelets</code> This function returns the <code>sibling</code> Lanelets of the input Lanelet excluding itself. The order is not defined. \\(O(E)\\) where \\(E\\) is the number of sibling Lanelets <code>from_ids</code> This function returns Lanelet objects in the same order as the input IDs. \\(O(n)\\) <code>&lt;autoware_lanelet2_utils/intersection.hpp&gt;</code> <code>is_intersection_lanelet</code> This function returns <code>true</code> if and only if the input Lanelet has <code>turn_direction</code> attribute. \\(O(1)\\) <code>is_straight_lanelet</code>,<code>is_left_lanelet</code>,<code>is_right_lanelet</code> This function returns <code>true</code> if and only if the input Lanelet has <code>turn_direction</code> attribute and its value is <code>straight</code>/<code>left</code>/<code>right</code>. \\(O(1)\\)"},{"location":"common/autoware_lanelet2_utils/#complexity-of-findusage","title":"complexity of <code>findUsage</code>","text":"<p>The readers should be noted that following description is implementation dependent.</p> <ul> <li>LaneletMap.h</li> <li>LaneletMap.cpp</li> </ul> <p>Lanelet map primitives(like <code>Lanelet</code>, <code>Area</code>, <code>RegulatoryElement</code>) are stored in several <code>PrimitiveLayer&lt;T&gt;</code> objects according to their types as shown below.</p> lanelet2_core/LaneletMap.h#L375-L438<pre><code>class LaneletMap : public LaneletMapLayers {\npublic:\nusing LaneletMapLayers::LaneletMapLayers;\n&lt;...&gt;\n};\n</code></pre> lanelet2_core/LaneletMap.h#L313-L359<pre><code>class LaneletMapLayers {\n&lt;...&gt;\nLaneletLayer laneletLayer;                      //!&lt; access to the lanelets within this map\nAreaLayer areaLayer;                            //!&lt; access to areas\nRegulatoryElementLayer regulatoryElementLayer;  //!&lt; access to regElems\nPolygonLayer polygonLayer;                      //!&lt; access to the polygons\nLineStringLayer lineStringLayer;                //!&lt; access to the lineStrings\nPointLayer pointLayer;                          //!&lt; access to the points\n};\n</code></pre> lanelet2_core/LaneletMap.h#L285-L303<pre><code>class LaneletLayer : public PrimitiveLayer&lt;Lanelet&gt; {\npublic:\nusing PrimitiveLayer::findUsages;\nLaneletLayer() = default;\n~LaneletLayer() = default;\nLaneletLayer(const LaneletLayer&amp;) = delete;\nLaneletLayer operator=(LaneletLayer&amp;) = delete;\nLanelets findUsages(const RegulatoryElementConstPtr&amp; regElem);\nConstLanelets findUsages(const RegulatoryElementConstPtr&amp; regElem) const;\n&lt;...&gt;\n};\n</code></pre> <p>Each <code>PrimitiveLayer</code> owns a field named <code>tree_</code> that contains a lookup table named <code>usage</code> of type <code>UsageLookup</code>,</p> lanelet2_core/LaneletMap.h#L38-L253<pre><code>template &lt;typename T&gt;\nclass PrimitiveLayer {\npublic:\n&lt;...&gt;\n/**\n   * @brief finds usages of an owned type within this layer\n   *\n   * This is the non-const version to find usages of a primitive in a layer.\n   */\nstd::vector&lt;PrimitiveT&gt; findUsages(const traits::ConstPrimitiveType&lt;traits::OwnedT&lt;PrimitiveT&gt;&gt;&amp; primitive);\n&lt;...&gt;\nstruct Tree;\n// NOLINTNEXTLINE\nstd::unique_ptr&lt;Tree&gt; tree_;  //!&lt; Hides boost trees from you/the compiler\n</code></pre> lanelet2_core/src/LaneletMap.cpp#L277-L308<pre><code>template &lt;typename T&gt;\nstruct PrimitiveLayer&lt;T&gt;::Tree {\nusing TreeNode = std::pair&lt;BoundingBox2d, T&gt;;\nusing RTree = bgi::rtree&lt;TreeNode, bgi::quadratic&lt;16&gt;&gt;;\nstatic TreeNode treeNode(const T&amp; elem) { return {geometry::boundingBox2d(to2D(elem)), elem}; }\n&lt;...&gt;\nRTree rTree;\nUsageLookup&lt;T&gt; usage;\n};\n</code></pre> <p>and <code>UsageLookup</code> contains reference relation between different types as <code>std::unordered_multimap</code>.</p> lanelet2_core/src/LaneletMap.cpp#L259-L270<pre><code>template &lt;&gt;\nstruct UsageLookup&lt;Lanelet&gt; {\nvoid add(Lanelet ll) {\nownedLookup.insert(std::make_pair(ll.leftBound(), ll));\nownedLookup.insert(std::make_pair(ll.rightBound(), ll));\nfor (const auto&amp; elem : ll.regulatoryElements()) {\nregElemLookup.insert(std::make_pair(elem, ll));\n}\n}\nstd::unordered_multimap&lt;ConstLineString3d, Lanelet&gt; ownedLookup;\nstd::unordered_multimap&lt;RegulatoryElementConstPtr, Lanelet&gt; regElemLookup;\n};\n</code></pre> <p>Thus the complexity of <code>findUsage</code> function is equal to that of <code>std::unordered_multimap::equal_range</code> which is \\(O(1)\\).</p> lanelet2_core/src/LaneletMap.cpp#L419-L424<pre><code>template &lt;typename T&gt;\nstd::vector&lt;typename PrimitiveLayer&lt;T&gt;::ConstPrimitiveT&gt; PrimitiveLayer&lt;T&gt;::findUsages(\nconst traits::ConstPrimitiveType&lt;traits::OwnedT&lt;PrimitiveLayer&lt;T&gt;::PrimitiveT&gt;&gt;&amp; primitive) const {\nreturn forEachMatchInMultiMap&lt;traits::ConstPrimitiveType&lt;typename PrimitiveLayer&lt;T&gt;::PrimitiveT&gt;&gt;(\ntree_-&gt;usage.ownedLookup, primitive, [](const auto&amp; elem) { return traits::toConst(elem.second); });\n}\n</code></pre> lanelet2_core/src/LaneletMap.cpp#L165-L169<pre><code>template &lt;typename T, typename MapT, typename KeyT, typename Func&gt;\nstd::vector&lt;T&gt; forEachMatchInMultiMap(const MapT&amp; map, const KeyT&amp; key, Func&amp;&amp; f) {\nauto range = map.equal_range(key);\nreturn utils::transform(range.first, range.second, f);\n}\n</code></pre>"},{"location":"common/autoware_lanelet2_utils/#test-maps","title":"Test maps","text":"<p>All of the maps are in <code>MGRS</code> coordinate. In each map, an anchor point is set to an origin point \\((100.0, 100.0)\\) for simplicity.</p> Map name Origin point id Image <code>road_shoulder/highway.osm</code> <code>1</code> <code>road_shoulder/pudo.osm</code> <code>140</code> <code>intersection/crossing.osm</code> <code>1791</code>"},{"location":"common/autoware_lanelet2_utils/#how-to-craft-test-map","title":"How to craft test map","text":"<p>On the VMB, create the map in MGRS system and save the file as <code>&lt;input_map.osm&gt;</code>. Next, select the point to set as origin, get its <code>&lt;ID&gt;</code> and run</p> <pre><code>ros2 run autoware_lanelet2_utility lanelet_anonymizer.py &lt;input_map.osm&gt; &lt;output_map.osm&gt; &lt;ID&gt;\n</code></pre> <p>Then the coordinate of the specified point is (100, 100) on the loaded map(NOTE: not exactly (0, 0) because MGRS does not any point to have negative coordinate value).</p> <p>By applying <code>lanelet_id_aligner.py</code>, the primitive ids are aligned to start from 1 and increase one-by-one.</p> <pre><code>ros2 run autoware_lanelet2_utility lanelet_id_aligner.py &lt;input_map.osm&gt;\n</code></pre>"},{"location":"common/autoware_motion_utils/","title":"Motion Utils package","text":""},{"location":"common/autoware_motion_utils/#motion-utils-package","title":"Motion Utils package","text":""},{"location":"common/autoware_motion_utils/#definition-of-terms","title":"Definition of terms","text":""},{"location":"common/autoware_motion_utils/#segment","title":"Segment","text":"<p><code>Segment</code> in Autoware is the line segment between two successive points as follows.</p> <p></p> <p>The nearest segment index and nearest point index to a certain position is not always th same. Therefore, we prepare two different utility functions to calculate a nearest index for points and segments.</p>"},{"location":"common/autoware_motion_utils/#nearest-index-search","title":"Nearest index search","text":"<p>In this section, the nearest index and nearest segment index search is explained.</p> <p>We have the same functions for the nearest index search and nearest segment index search. Taking for the example the nearest index search, we have two types of functions.</p> <p>The first function finds the nearest index with distance and yaw thresholds.</p> <pre><code>template &lt;class T&gt;\nsize_t findFirstNearestIndexWithSoftConstraints(\nconst T &amp; points, const geometry_msgs::msg::Pose &amp; pose,\nconst double dist_threshold = std::numeric_limits&lt;double&gt;::max(),\nconst double yaw_threshold = std::numeric_limits&lt;double&gt;::max());\n</code></pre> <p>This function finds the first local solution within thresholds. The reason to find the first local one is to deal with some edge cases explained in the next subsection.</p> <p>There are default parameters for thresholds arguments so that you can decide which thresholds to pass to the function.</p> <ol> <li>When both the distance and yaw thresholds are given.<ul> <li>First, try to find the nearest index with both the distance and yaw thresholds.</li> <li>If not found, try to find again with only the distance threshold.</li> <li>If not found, find without any thresholds.</li> </ul> </li> <li>When only distance are given.<ul> <li>First, try to find the nearest index the distance threshold.</li> <li>If not found, find without any thresholds.</li> </ul> </li> <li>When no thresholds are given.<ul> <li>Find the nearest index.</li> </ul> </li> </ol> <p>The second function finds the nearest index in the lane whose id is <code>lane_id</code>.</p> <pre><code>size_t findNearestIndexFromLaneId(\nconst autoware_internal_planning_msgs::msg::PathWithLaneId &amp; path,\nconst geometry_msgs::msg::Point &amp; pos, const int64_t lane_id);\n</code></pre>"},{"location":"common/autoware_motion_utils/#application-to-various-object","title":"Application to various object","text":"<p>Many node packages often calculate the nearest index of objects. We will explain the recommended method to calculate it.</p>"},{"location":"common/autoware_motion_utils/#nearest-index-for-the-ego","title":"Nearest index for the ego","text":"<p>Assuming that the path length before the ego is short enough, we expect to find the correct nearest index in the following edge cases by <code>findFirstNearestIndexWithSoftConstraints</code> with both distance and yaw thresholds. Blue circles describes the distance threshold from the base link position and two blue lines describe the yaw threshold against the base link orientation. Among points in these cases, the correct nearest point which is red can be found.</p> <p></p> <p>Therefore, the implementation is as follows.</p> <pre><code>const size_t ego_nearest_idx = findFirstNearestIndexWithSoftConstraints(points, ego_pose, ego_nearest_dist_threshold, ego_nearest_yaw_threshold);\nconst size_t ego_nearest_seg_idx = findFirstNearestIndexWithSoftConstraints(points, ego_pose, ego_nearest_dist_threshold, ego_nearest_yaw_threshold);\n</code></pre>"},{"location":"common/autoware_motion_utils/#nearest-index-for-dynamic-objects","title":"Nearest index for dynamic objects","text":"<p>For the ego nearest index, the orientation is considered in addition to the position since the ego is supposed to follow the points. However, for the dynamic objects (e.g., predicted object), sometimes its orientation may be different from the points order, e.g. the dynamic object driving backward although the ego is driving forward.</p> <p>Therefore, the yaw threshold should not be considered for the dynamic object. The implementation is as follows.</p> <pre><code>const size_t dynamic_obj_nearest_idx = findFirstNearestIndexWithSoftConstraints(points, dynamic_obj_pose, dynamic_obj_nearest_dist_threshold);\nconst size_t dynamic_obj_nearest_seg_idx = findFirstNearestIndexWithSoftConstraints(points, dynamic_obj_pose, dynamic_obj_nearest_dist_threshold);\n</code></pre>"},{"location":"common/autoware_motion_utils/#nearest-index-for-traffic-objects","title":"Nearest index for traffic objects","text":"<p>In lanelet maps, traffic objects belong to the specific lane. With this specific lane's id, the correct nearest index can be found.</p> <p>The implementation is as follows.</p> <pre><code>// first extract `lane_id` which the traffic object belong to.\nconst size_t traffic_obj_nearest_idx = findNearestIndexFromLaneId(path_with_lane_id, traffic_obj_pos, lane_id);\nconst size_t traffic_obj_nearest_seg_idx = findNearestSegmentIndexFromLaneId(path_with_lane_id, traffic_obj_pos, lane_id);\n</code></pre>"},{"location":"common/autoware_motion_utils/#for-developers","title":"For developers","text":"<p>Some of the template functions in <code>trajectory.hpp</code> are mostly used for specific types (<code>autoware_planning_msgs::msg::PathPoint</code>, <code>autoware_planning_msgs::msg::PathPoint</code>, <code>autoware_planning_msgs::msg::TrajectoryPoint</code>), so they are exported as <code>extern template</code> functions to speed-up compilation time.</p> <p><code>autoware_motion_utils.hpp</code> header file was removed because the source files that directly/indirectly include this file took a long time for preprocessing.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/","title":"vehicle utils","text":""},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle-utils","title":"vehicle utils","text":"<p>Vehicle utils provides a convenient library used to check vehicle status.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#feature","title":"Feature","text":"<p>The library contains following classes.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle_stop_checker","title":"vehicle_stop_checker","text":"<p>This class check whether the vehicle is stopped or not based on localization result.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#subscribed-topics","title":"Subscribed Topics","text":"Name Type Description <code>/localization/kinematic_state</code> <code>nav_msgs::msg::Odometry</code> vehicle odometry"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#parameters","title":"Parameters","text":"Name Type Default Value Explanation <code>velocity_buffer_time_sec</code> double 10.0 odometry buffering time [s]"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#member-functions","title":"Member functions","text":"<pre><code>bool isVehicleStopped(const double stop_duration)\n</code></pre> <ul> <li>Check simply whether the vehicle is stopped based on the localization result.</li> <li>Returns <code>true</code> if the vehicle is stopped, even if system outputs a non-zero target velocity.</li> </ul>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#example-usage","title":"Example Usage","text":"<p>Necessary includes:</p> <pre><code>#include &lt;autoware_utils/vehicle/vehicle_state_checker.hpp&gt;\n</code></pre> <p>1.Create a checker instance.</p> <pre><code>class SampleNode : public rclcpp::Node\n{\npublic:\nSampleNode() : Node(\"sample_node\")\n{\nvehicle_stop_checker_ = std::make_unique&lt;VehicleStopChecker&gt;(this);\n}\n\nstd::unique_ptr&lt;VehicleStopChecker&gt; vehicle_stop_checker_;\n\nbool sampleFunc();\n\n...\n}\n</code></pre> <p>2.Check the vehicle state.</p> <pre><code>bool SampleNode::sampleFunc()\n{\n...\n\nconst auto result_1 = vehicle_stop_checker_-&gt;isVehicleStopped();\n\n...\n\nconst auto result_2 = vehicle_stop_checker_-&gt;isVehicleStopped(3.0);\n\n...\n}\n</code></pre>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#vehicle_arrival_checker","title":"vehicle_arrival_checker","text":"<p>This class check whether the vehicle arrive at stop point based on localization and planning result.</p>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#subscribed-topics_1","title":"Subscribed Topics","text":"Name Type Description <code>/localization/kinematic_state</code> <code>nav_msgs::msg::Odometry</code> vehicle odometry <code>/planning/scenario_planning/trajectory</code> <code>autoware_planning_msgs::msg::Trajectory</code> trajectory"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#parameters_1","title":"Parameters","text":"Name Type Default Value Explanation <code>velocity_buffer_time_sec</code> double 10.0 odometry buffering time [s] <code>th_arrived_distance_m</code> double 1.0 threshold distance to check if vehicle has arrived at target point [m]"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#member-functions_1","title":"Member functions","text":"<pre><code>bool isVehicleStopped(const double stop_duration)\n</code></pre> <ul> <li>Check simply whether the vehicle is stopped based on the localization result.</li> <li>Returns <code>true</code> if the vehicle is stopped, even if system outputs a non-zero target velocity.</li> </ul> <pre><code>bool isVehicleStoppedAtStopPoint(const double stop_duration)\n</code></pre> <ul> <li>Check whether the vehicle is stopped at stop point based on the localization and planning result.</li> <li>Returns <code>true</code> if the vehicle is not only stopped but also arrived at stop point.</li> </ul>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#example-usage_1","title":"Example Usage","text":"<p>Necessary includes:</p> <pre><code>#include &lt;autoware_utils/vehicle/vehicle_state_checker.hpp&gt;\n</code></pre> <p>1.Create a checker instance.</p> <pre><code>class SampleNode : public rclcpp::Node\n{\npublic:\nSampleNode() : Node(\"sample_node\")\n{\nvehicle_arrival_checker_ = std::make_unique&lt;VehicleArrivalChecker&gt;(this);\n}\n\nstd::unique_ptr&lt;VehicleArrivalChecker&gt; vehicle_arrival_checker_;\n\nbool sampleFunc();\n\n...\n}\n</code></pre> <p>2.Check the vehicle state.</p> <pre><code>bool SampleNode::sampleFunc()\n{\n...\n\nconst auto result_1 = vehicle_arrival_checker_-&gt;isVehicleStopped();\n\n...\n\nconst auto result_2 = vehicle_arrival_checker_-&gt;isVehicleStopped(3.0);\n\n...\n\nconst auto result_3 = vehicle_arrival_checker_-&gt;isVehicleStoppedAtStopPoint();\n\n...\n\nconst auto result_4 = vehicle_arrival_checker_-&gt;isVehicleStoppedAtStopPoint(3.0);\n\n...\n}\n</code></pre>"},{"location":"common/autoware_motion_utils/docs/vehicle/vehicle/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p><code>vehicle_stop_checker</code> and <code>vehicle_arrival_checker</code> cannot check whether the vehicle is stopped more than <code>velocity_buffer_time_sec</code> second.</p>"},{"location":"common/autoware_node/","title":"Autoware Node","text":""},{"location":"common/autoware_node/#autoware-node","title":"Autoware Node","text":""},{"location":"common/autoware_node/#abbreviations","title":"Abbreviations","text":"<ul> <li>AN: Autoware Node</li> </ul>"},{"location":"common/autoware_node/#overview","title":"Overview","text":"<p>AN is an <code>autoware.core</code> package designed to provide a base class for all future nodes in the system.</p>"},{"location":"common/autoware_node/#usage","title":"Usage","text":"<p>Check the autoware_test_node package for an example of how to use <code>autoware::Node</code>.</p>"},{"location":"common/autoware_object_recognition_utils/","title":"autoware_object_recognition_utils","text":""},{"location":"common/autoware_object_recognition_utils/#autoware_object_recognition_utils","title":"autoware_object_recognition_utils","text":""},{"location":"common/autoware_object_recognition_utils/#overview","title":"Overview","text":"<p>This package contains a library of common functions that are useful across the perception module and planning module.</p>"},{"location":"common/autoware_object_recognition_utils/#design","title":"Design","text":""},{"location":"common/autoware_object_recognition_utils/#conversion","title":"Conversion","text":"<p>Ensuring accurate and efficient converting between DetectedObject and TrackedObject types.</p>"},{"location":"common/autoware_object_recognition_utils/#geometry","title":"Geometry","text":"<p>It provides specialized implementations for each object type (e.g., DetectedObject, TrackedObject, and PredictedObject) to extract the pose information.</p>"},{"location":"common/autoware_object_recognition_utils/#matching","title":"Matching","text":"<p>It provides utility functions for calculating geometrical metrics, such as 2D IoU (Intersection over Union), GIoU (Generalized IoU), Precision, and Recall for objects. It also provides helper functions for computing areas of intersections, unions, and convex hulls of polygon</p>"},{"location":"common/autoware_object_recognition_utils/#object-classification","title":"Object Classification","text":"<p>Designed for processing and classifying detected objects, it implements the following functionalities:</p> <ul> <li>Handling of vehicle category checks</li> <li>Conversion between string class names and numerical labels</li> <li>Probability-based classification selection</li> <li>String representation of object labels</li> </ul>"},{"location":"common/autoware_object_recognition_utils/#predicted-path-utils","title":"Predicted Path Utils","text":"<p>Providing utility functions for handling predicted paths of objects. It includes the following functionalities:</p> <ul> <li>calcInterpolatedPose: Calculates an interpolated pose from a predicted path based on a given time.</li> <li>resamplePredictedPath (version 1): Resamples a predicted path according to a specified time vector, optionally using spline interpolation for smoother results.</li> <li>resamplePredictedPath (version 2): Resamples a predicted path at regular time intervals, including the terminal point, with optional spline interpolation.</li> </ul>"},{"location":"common/autoware_object_recognition_utils/#usage","title":"Usage","text":"<p>include all-in-one header files if multiple functionalities are needed:</p> <pre><code>#include &lt;autoware_object_recognition_utils/object_recognition_utils.hpp&gt;\n</code></pre> <p>include specific header files if only a subset of functionalities is needed:</p> <pre><code>#include &lt;autoware_object_recognition_utils/object_classifier.hpp&gt;\n</code></pre>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/","title":"Interface for the OSQP library","text":""},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#interface-for-the-osqp-library","title":"Interface for the OSQP library","text":"<p>This is the design document for the <code>autoware_osqp_interface</code> package.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>This packages provides a C++ interface for the OSQP library.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#design","title":"Design","text":"<p>The class <code>OSQPInterface</code> takes a problem formulation as Eigen matrices and vectors, converts these objects into C-style Compressed-Column-Sparse matrices and dynamic arrays, loads the data into the OSQP workspace dataholder, and runs the optimizer.</p>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>The interface can be used in several ways:</p> <ol> <li> <p>Initialize the interface WITHOUT data. Load the problem formulation at the optimization call.</p> <pre><code>    osqp_interface = OSQPInterface();\nosqp_interface.optimize(P, A, q, l, u);\n</code></pre> </li> <li> <p>Initialize the interface WITH data.</p> <pre><code>    osqp_interface = OSQPInterface(P, A, q, l, u);\nosqp_interface.optimize();\n</code></pre> </li> <li> <p>WARM START OPTIMIZATION by modifying the problem formulation between optimization runs.</p> <pre><code>    osqp_interface = OSQPInterface(P, A, q, l, u);\nosqp_interface.optimize();\nosqp.initializeProblem(P_new, A_new, q_new, l_new, u_new);\nosqp_interface.optimize();\n</code></pre> <p>The optimization results are returned as a vector by the optimization function.</p> <pre><code>std::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt; result = osqp_interface.optimize();\nstd::vector&lt;double&gt; param = std::get&lt;0&gt;(result);\ndouble x_0 = param[0];\ndouble x_1 = param[1];\n</code></pre> </li> </ol>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#references-external-links","title":"References / External links","text":"<ul> <li>OSQP library: https://osqp.org/</li> </ul>"},{"location":"common/autoware_osqp_interface/design/osqp_interface-design/#related-issues","title":"Related issues","text":""},{"location":"common/autoware_point_types/","title":"Autoware Point Types","text":""},{"location":"common/autoware_point_types/#autoware-point-types","title":"Autoware Point Types","text":""},{"location":"common/autoware_point_types/#overview","title":"Overview","text":"<p>This package provides a variety of structures to represent different types of point cloud data, mainly used for point cloud processing and analysis.</p>"},{"location":"common/autoware_point_types/#design","title":"Design","text":""},{"location":"common/autoware_point_types/#point-cloud-data-type-definition","title":"Point cloud data type definition","text":"<p><code>autoware_point_types</code> defines multiple structures (such as PointXYZI, PointXYZIRC, PointXYZIRADRT, PointXYZIRCAEDT), each structure contains different attributes to adapt to different application scenarios.</p> <ul> <li><code>autoware::point_types::PointXYZI</code>: Point type with intensity information.</li> <li><code>autoware::point_types::PointXYZIRC</code>: Extended PointXYZI, adds return_type and channel information.</li> <li><code>autoware::point_types::PointXYZIRADRT</code>: Extended PointXYZI, adds ring, azimuth, distance, return_type and time_stamp information.</li> <li><code>autoware::point_types::PointXYZIRCAEDT</code>: Similar to PointXYZIRADRT, but adds elevation information and uses <code>std::uint32_t</code> as the data type for time_stamp.</li> </ul>"},{"location":"common/autoware_point_types/#operator-overload","title":"Operator overload","text":"<p>Each structure overloads the <code>==</code> operator, allowing users to easily compare whether two points are equal, which is very useful for deduplication and matching of point cloud data.</p>"},{"location":"common/autoware_point_types/#field-generators","title":"Field generators","text":"<p>The field generator is implemented using macro definitions and std::tuple, which simplifies the serialization and deserialization process of point cloud messages and improves the reusability and readability of the code.</p>"},{"location":"common/autoware_point_types/#registration-mechanism","title":"Registration mechanism","text":"<p>Register custom point cloud structures into the PCL library through the macro <code>POINT_CLOUD_REGISTER_POINT_STRUCT</code>, so that these structures can be directly integrated with other functions of the PCL library.</p>"},{"location":"common/autoware_point_types/#usage","title":"Usage","text":"<ul> <li>Create a point cloud object of PointXYZIRC type</li> </ul> <pre><code>#include \"autoware/point_types/types.hpp\"\n\nint main(){\npcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;::Ptr cloud(new pcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;());\n\nfor (int i = 0; i &lt; 5; ++i) {\nautoware::point_types::PointXYZIRC point;\npoint.x = static_cast&lt;float&gt;(i * 0.1);\npoint.y = static_cast&lt;float&gt;(i * 0.2);\npoint.z = static_cast&lt;float&gt;(i * 0.3);\npoint.intensity = static_cast&lt;std::uint8_t&gt;(i * 10);\npoint.return_type = autoware::point_types::ReturnType::SINGLE_STRONGEST;\npoint.channel = static_cast&lt;std::uint16_t&gt;(i);\n\ncloud-&gt;points.push_back(point);\n}\ncloud-&gt;width = cloud-&gt;points.size();\ncloud-&gt;height = 1;\n\nreturn 0;\n}\n</code></pre> <ul> <li>Convert ROS message to point cloud of PointXYZIRC type</li> </ul> <pre><code>ExampleNode::points_callback(const PointCloud2::ConstSharedPtr &amp; points_msg_ptr)\n{\npcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;::Ptr points_ptr(\nnew pcl::PointCloud&lt;autoware::point_types::PointXYZIRC&gt;);\n\npcl::fromROSMsg(*points_msg_ptr, *points_ptr);\n}\n</code></pre>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/","title":"Interface for QP solvers","text":""},{"location":"common/autoware_qp_interface/design/qp_interface-design/#interface-for-qp-solvers","title":"Interface for QP solvers","text":"<p>This is the design document for the <code>autoware_qp_interface</code> package.</p>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>This packages provides a C++ interface for QP solvers. Currently, supported QP solvers are</p> <ul> <li>OSQP library</li> </ul>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#design","title":"Design","text":"<p>The class <code>QPInterface</code> takes a problem formulation as Eigen matrices and vectors, converts these objects into C-style Compressed-Column-Sparse matrices and dynamic arrays, loads the data into the QP workspace dataholder, and runs the optimizer.</p>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>The interface can be used in several ways:</p> <ol> <li> <p>Initialize the interface, and load the problem formulation at the optimization call.</p> <pre><code>    QPInterface qp_interface;\nqp_interface.optimize(P, A, q, l, u);\n</code></pre> </li> <li> <p>WARM START OPTIMIZATION by modifying the problem formulation between optimization runs.</p> <pre><code>    QPInterface qp_interface(true);\nqp_interface.optimize(P, A, q, l, u);\nqp_interface.optimize(P_new, A_new, q_new, l_new, u_new);\n</code></pre> <p>The optimization results are returned as a vector by the optimization function.</p> <pre><code>const auto solution = qp_interface.optimize();\ndouble x_0 = solution[0];\ndouble x_1 = solution[1];\n</code></pre> </li> </ol>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#references-external-links","title":"References / External links","text":"<ul> <li>OSQP library: https://osqp.org/</li> </ul>"},{"location":"common/autoware_qp_interface/design/qp_interface-design/#related-issues","title":"Related issues","text":""},{"location":"common/autoware_trajectory/","title":"Autoware Trajectory","text":""},{"location":"common/autoware_trajectory/#autoware-trajectory","title":"Autoware Trajectory","text":"<p>This package provides classes to manage/manipulate Trajectory.</p>"},{"location":"common/autoware_trajectory/#example-usage","title":"Example Usage","text":"<p>This section describes Example Usage of <code>Trajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;</code></p> <ul> <li> <p>Load Trajectory from point array</p> <pre><code>#include \"autoware/trajectory/path_point.hpp\"\n\n...\n\nstd::vector&lt;autoware_planning_msgs::msg::PathPoint&gt; points = ... // Load points from somewhere\n\nusing autoware::trajectory::Trajectory;\n\nstd::optional&lt;Trajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;&gt; trajectory =\nTrajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;::Builder{}\n.build(points);\n</code></pre> </li> </ul> <ul> <li> <p>You can also specify interpolation method</p> <pre><code>using autoware::trajectory::interpolator::CubicSpline;\n\nstd::optional&lt;Trajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;&gt; trajectory =\nTrajectory&lt;autoware_planning_msgs::msg::PathPoint&gt;::Builder{}\n.set_xy_interpolator&lt;CubicSpline&gt;()  // Set interpolator for x-y plane\n.build(points);\n</code></pre> </li> </ul> <ul> <li> <p>Access point on Trajectory</p> <pre><code>autoware_planning_msgs::msg::PathPoint point = trajectory-&gt;compute(1.0);  // Get point at s=0.0. s is distance from start point on Trajectory.\n</code></pre> </li> </ul> <ul> <li> <p>Get length of Trajectory</p> <pre><code>double length = trajectory-&gt;length();\n</code></pre> </li> </ul> <ul> <li> <p>Set 3.0[m] ~ 5.0[m] part of velocity to 0.0</p> <pre><code>trajectory-&gt;longitudinal_velocity_mps(3.0, 5.0) = 0.0;\n</code></pre> </li> </ul> <ul> <li> <p>Crop Trajectory from 1.0[m] to 2.0[m]</p> <pre><code>trajectory-&gt;crop(1.0, 2.0);\n</code></pre> </li> </ul> <ul> <li> <p>Restore points</p> <pre><code>std::vector&lt;autoware_planning_msgs::msg::PathPoint&gt; points = trajectory-&gt;restore();\n</code></pre> </li> </ul>"},{"location":"common/autoware_vehicle_info_utils/","title":"Vehicle Info Util","text":""},{"location":"common/autoware_vehicle_info_utils/#vehicle-info-util","title":"Vehicle Info Util","text":""},{"location":"common/autoware_vehicle_info_utils/#purpose","title":"Purpose","text":"<p>This package is to get vehicle info parameters.</p>"},{"location":"common/autoware_vehicle_info_utils/#description","title":"Description","text":"<p>In here, you can check the vehicle dimensions with more detail. The current format supports only the Ackermann model. This file defines the model assumed in autoware path planning, control, etc. and does not represent the exact physical model. If a model other than the Ackermann model is used, it is assumed that a vehicle interface will be designed to change the control output for the model.</p>"},{"location":"common/autoware_vehicle_info_utils/#versioning-policy","title":"Versioning Policy","text":"<p>We have implemented a versioning system for the <code>vehicle_info.param.yaml</code> file to ensure clarity and consistency in file format across different versions of Autoware and its external applications. Please see discussion for the details.</p>"},{"location":"common/autoware_vehicle_info_utils/#how-to-operate","title":"How to Operate","text":"<ul> <li>The current file format is set as an unversioned base version (<code>version:</code> field is commented out).</li> <li>For the next update involving changes (such as additions, deletions, or modifications):<ul> <li>Uncomment and update the version line at the beginning of the file.</li> <li>Initiate versioning by assigning a version number, starting from <code>0.1.0</code>. Follow the semantic versioning format (MAJOR.MINOR.PATCH).</li> <li>Update this Readme.md too.</li> </ul> </li> <li>For subsequent updates, continue incrementing the version number in accordance with the changes made.<ul> <li>Discuss how to increment version depending on the amount of changes made to the file.</li> </ul> </li> </ul> <pre><code>/**:\nros__parameters:\n# version: 0.1.0 # Uncomment and update this line for future format changes.\nwheel_radius: 0.383\n...\n</code></pre>"},{"location":"common/autoware_vehicle_info_utils/#why-versioning","title":"Why Versioning?","text":"<ul> <li>Consistency Across Updates: Implementing version control will allow accurate tracking of changes over time and changes in vehicle information parameters.</li> <li>Clarity for External Applications: External applications that depend on <code>vehicle_info.param.yaml</code> need to reference the correct file version for optimal compatibility and functionality.</li> <li>Simplified Management for Customized Branches: Assigning versions directly to the <code>vehicle_info.param.yaml</code> file simplifies management compared to maintaining separate versions for multiple customized Autoware branches. This approach streamlines version tracking and reduces complexity.</li> </ul>"},{"location":"common/autoware_vehicle_info_utils/#scripts","title":"Scripts","text":""},{"location":"common/autoware_vehicle_info_utils/#minimum-turning-radius","title":"Minimum turning radius","text":"<pre><code>$ ros2 run autoware_vehicle_info_utils min_turning_radius_calculator.py\nyaml path is /home/autoware/pilot-auto/install/autoware_vehicle_info_utils/share/autoware_vehicle_info_utils/config/vehicle_info.param.yaml\nMinimum turning radius is 3.253042620027102 [m] for rear, 4.253220695862465 [m] for front.\n</code></pre> <p>You can designate yaml file with <code>-y</code> option as follows.</p> <pre><code>ros2 run autoware_vehicle_info_utils min_turning_radius_calculator.py -y &lt;path-to-yaml&gt;\n</code></pre>"},{"location":"common/autoware_vehicle_info_utils/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>TBD.</p>"},{"location":"demos/autoware_test_node/","title":"autoware_test_node","text":""},{"location":"demos/autoware_test_node/#autoware_test_node","title":"autoware_test_node","text":"<p>This package contains a simple example of how to use <code>autoware::Node</code>.</p>"},{"location":"demos/autoware_test_node/#usage","title":"Usage","text":"<pre><code>ros2 launch autoware_test_node autoware_test_node.launch.xml\n</code></pre>"},{"location":"localization/autoware_ekf_localizer/","title":"Overview","text":""},{"location":"localization/autoware_ekf_localizer/#overview","title":"Overview","text":"<p>The Extend Kalman Filter Localizer estimates robust and less noisy robot pose and twist by integrating the 2D vehicle dynamics model with input ego-pose and ego-twist messages. The algorithm is designed especially for fast-moving robots such as autonomous driving systems.</p>"},{"location":"localization/autoware_ekf_localizer/#flowchart","title":"Flowchart","text":"<p>The overall flowchart of the autoware_ekf_localizer is described below.</p> <p> </p>"},{"location":"localization/autoware_ekf_localizer/#features","title":"Features","text":"<p>This package includes the following features:</p> <ul> <li>Time delay compensation for input messages, which enables proper integration of input information with varying time delays. This is important especially for high-speed moving robots, such as autonomous driving vehicles. (see the following figure).</li> <li>Automatic estimation of yaw bias prevents modeling errors caused by sensor mounting angle errors, which can improve estimation accuracy.</li> <li>Mahalanobis distance gate enables probabilistic outlier detection to determine which inputs should be used or ignored.</li> <li>Smooth update, the Kalman Filter measurement update is typically performed when a measurement is obtained, but it can cause large changes in the estimated value, especially for low-frequency measurements. Since the algorithm can consider the measurement time, the measurement data can be divided into multiple pieces and integrated smoothly while maintaining consistency (see the following figure).</li> <li>Calculation of vertical correction amount from pitch mitigates localization instability on slopes. For example, when going uphill, it behaves as if it is buried in the ground (see the left side of the \"Calculate delta from pitch\" figure) because EKF only considers 3DoF(x,y,yaw). Therefore, EKF corrects the z-coordinate according to the formula (see the right side of the \"Calculate delta from pitch\" figure).</li> </ul> <p> </p> <p> </p> <p> </p>"},{"location":"localization/autoware_ekf_localizer/#node","title":"Node","text":""},{"location":"localization/autoware_ekf_localizer/#subscribed-topics","title":"Subscribed Topics","text":"Name Type Description <code>measured_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Input pose source with the measurement covariance matrix. <code>measured_twist_with_covariance</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> Input twist source with the measurement covariance matrix. <code>initialpose</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Initial pose for EKF. The estimated pose is initialized with zeros at the start. It is initialized with this message whenever published."},{"location":"localization/autoware_ekf_localizer/#published-topics","title":"Published Topics","text":"Name Type Description <code>ekf_odom</code> <code>nav_msgs::msg::Odometry</code> Estimated odometry. <code>ekf_pose</code> <code>geometry_msgs::msg::PoseStamped</code> Estimated pose. <code>ekf_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Estimated pose with covariance. <code>ekf_biased_pose</code> <code>geometry_msgs::msg::PoseStamped</code> Estimated pose including the yaw bias <code>ekf_biased_pose_with_covariance</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> Estimated pose with covariance including the yaw bias <code>ekf_twist</code> <code>geometry_msgs::msg::TwistStamped</code> Estimated twist. <code>ekf_twist_with_covariance</code> <code>geometry_msgs::msg::TwistWithCovarianceStamped</code> The estimated twist with covariance. <code>diagnostics</code> <code>diagnostics_msgs::msg::DiagnosticArray</code> The diagnostic information. <code>debug/processing_time_ms</code> <code>autoware_internal_debug_msgs::msg::Float64Stamped</code> The processing time [ms]."},{"location":"localization/autoware_ekf_localizer/#published-tf","title":"Published TF","text":"<ul> <li>base_link   TF from <code>map</code> coordinate to estimated pose.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#functions","title":"Functions","text":""},{"location":"localization/autoware_ekf_localizer/#predict","title":"Predict","text":"<p>The current robot state is predicted from previously estimated data using a given prediction model. This calculation is called at a constant interval (<code>predict_frequency [Hz]</code>). The prediction equation is described at the end of this page.</p>"},{"location":"localization/autoware_ekf_localizer/#measurement-update","title":"Measurement Update","text":"<p>Before the update, the Mahalanobis distance is calculated between the measured input and the predicted state, the measurement update is not performed for inputs where the Mahalanobis distance exceeds the given threshold.</p> <p>The predicted state is updated with the latest measured inputs, measured_pose, and measured_twist. The updates are performed with the same frequency as prediction, usually at a high frequency, in order to enable smooth state estimation.</p>"},{"location":"localization/autoware_ekf_localizer/#parameter-description","title":"Parameter description","text":"<p>The parameters are set in <code>launch/ekf_localizer.launch</code> .</p>"},{"location":"localization/autoware_ekf_localizer/#for-node","title":"For Node","text":"Name Type Description Default Range show_debug_info boolean Flag to display debug info 0 N/A predict_frequency float Frequency for filtering and publishing [Hz] 50 N/A tf_rate float Frequency for tf broadcasting [Hz] 50 N/A extend_state_step integer Max delay step which can be dealt with in EKF. Large number increases computational cost. 50 N/A enable_yaw_bias_estimation boolean Flag to enable yaw bias estimation 1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-pose-measurement","title":"For pose measurement","text":"Name Type Description Default Range pose_additional_delay float Additional delay time for pose measurement [s] 0 N/A pose_measure_uncertainty_time float Measured time uncertainty used for covariance calculation [s] 0.01 N/A pose_smoothing_steps integer A value for smoothing steps 5 N/A pose_gate_dist float Limit of Mahalanobis distance used for outliers detection 49.5 N/A"},{"location":"localization/autoware_ekf_localizer/#for-twist-measurement","title":"For twist measurement","text":"Name Type Description Default Range twist_additional_delay float Additional delay time for twist [s] 0 N/A twist_smoothing_steps integer A value for smoothing steps 2 N/A twist_gate_dist float Limit of Mahalanobis distance used for outliers detection 46.1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-process-noise","title":"For process noise","text":"Name Type Description Default Range proc_stddev_vx_c float Standard deviation of process noise in time differentiation expression of linear velocity x, noise for d_vx = 0 10 N/A proc_stddev_wz_c float Standard deviation of process noise in time differentiation expression of angular velocity z, noise for d_wz = 0 5 N/A proc_stddev_yaw_c float Standard deviation of process noise in time differentiation expression of yaw, noise for d_yaw = omega 0.005 N/A <p>note: process noise for positions x &amp; y are calculated automatically from nonlinear dynamics.</p>"},{"location":"localization/autoware_ekf_localizer/#simple-1d-filter-parameters","title":"Simple 1D Filter Parameters","text":"Name Type Description Default Range z_filter_proc_dev float Simple1DFilter - Z filter process deviation 1 N/A roll_filter_proc_dev float Simple1DFilter - Roll filter process deviation 0.1 N/A pitch_filter_proc_dev float Simple1DFilter - Pitch filter process deviation 0.1 N/A"},{"location":"localization/autoware_ekf_localizer/#for-diagnostics","title":"For diagnostics","text":"Name Type Description Default Range pose_no_update_count_threshold_warn integer The threshold at which a WARN state is triggered due to the Pose Topic update not happening continuously for a certain number of times 50 N/A pose_no_update_count_threshold_error integer The threshold at which an ERROR state is triggered due to the Pose Topic update not happening continuously for a certain number of times 100 N/A twist_no_update_count_threshold_warn integer The threshold at which a WARN state is triggered due to the Twist Topic update not happening continuously for a certain number of times 50 N/A twist_no_update_count_threshold_error integer The threshold at which an ERROR state is triggered due to the Twist Topic update not happening continuously for a certain number of times 100 N/A ellipse_scale float The scale factor to apply the error ellipse size 3 N/A error_ellipse_size float The long axis size of the error ellipse to trigger a ERROR state 1.5 N/A warn_ellipse_size float The long axis size of the error ellipse to trigger a WARN state 1.2 N/A error_ellipse_size_lateral_direction float The lateral direction size of the error ellipse to trigger a ERROR state 0.3 N/A warn_ellipse_size_lateral_direction float The lateral direction size of the error ellipse to trigger a WARN state 0.25 N/A"},{"location":"localization/autoware_ekf_localizer/#misc","title":"Misc","text":"Name Type Description Default Range threshold_observable_velocity_mps float Minimum value for velocity that will be used for EKF. Mainly used for dead zone in velocity sensor [m/s] (0.0 means disabled) 0.0 N/A pose_frame_id string Parent frame_id of EKF output pose map N/A"},{"location":"localization/autoware_ekf_localizer/#how-to-tune-ekf-parameters","title":"How to tune EKF parameters","text":""},{"location":"localization/autoware_ekf_localizer/#0-preliminaries","title":"0. Preliminaries","text":"<ul> <li>Check header time in pose and twist message is set to sensor time appropriately, because time delay is calculated from this value. If it is difficult to set an appropriate time due to the timer synchronization problem, use <code>twist_additional_delay</code> and <code>pose_additional_delay</code> to correct the time.</li> <li>Check if the relation between measurement pose and twist is appropriate (whether the derivative of the pose has a similar value to twist). This discrepancy is caused mainly by unit error (such as confusing radian/degree) or bias noise, and it causes large estimation errors.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#1-tune-sensor-parameters","title":"1. Tune sensor parameters","text":"<p>Set standard deviation for each sensor. The <code>pose_measure_uncertainty_time</code> is for the uncertainty of the header timestamp data. You can also tune a number of steps for smoothing for each observed sensor data by tuning <code>*_smoothing_steps</code>. Increasing the number will improve the smoothness of the estimation, but may have an adverse effect on the estimation performance.</p> <ul> <li><code>pose_measure_uncertainty_time</code></li> <li><code>pose_smoothing_steps</code></li> <li><code>twist_smoothing_steps</code></li> </ul>"},{"location":"localization/autoware_ekf_localizer/#2-tune-process-model-parameters","title":"2. Tune process model parameters","text":"<ul> <li><code>proc_stddev_vx_c</code> : set to maximum linear acceleration</li> <li><code>proc_stddev_wz_c</code> : set to maximum angular acceleration</li> <li><code>proc_stddev_yaw_c</code> : This parameter describes the correlation between the yaw and yaw rate. A large value means the change in yaw does not correlate to the estimated yaw rate. If this is set to 0, it means the change in estimated yaw is equal to yaw rate. Usually, this should be set to 0.</li> <li><code>proc_stddev_yaw_bias_c</code> : This parameter is the standard deviation for the rate of change in yaw bias. In most cases, yaw bias is constant, so it can be very small, but must be non-zero.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#3-tune-gate-parameters","title":"3. Tune gate parameters","text":"<p>EKF performs gating using Mahalanobis distance before updating by observation. The gate size is determined by the <code>pose_gate_dist</code> parameter and the <code>twist_gate_dist</code>. If the Mahalanobis distance is larger than this value, the observation is ignored.</p> <p>This gating process is based on a statistical test using the chi-square distribution. As modeled, we assume that the Mahalanobis distance follows a chi-square distribution with 3 degrees of freedom for pose and 2 degrees of freedom for twist.</p> <p>Currently, the accuracy of covariance estimation itself is not very good, so it is recommended to set the significance level to a very small value to reduce rejection due to false positives.</p> Significance level Threshold for 2 dof Threshold for 3 dof \\(10 ^ {-2}\\) 9.21 11.3 \\(10 ^ {-3}\\) 13.8 16.3 \\(10 ^ {-4}\\) 18.4 21.1 \\(10 ^ {-5}\\) 23.0 25.9 \\(10 ^ {-6}\\) 27.6 30.7 \\(10 ^ {-7}\\) 32.2 35.4 \\(10 ^ {-8}\\) 36.8 40.1 \\(10 ^ {-9}\\) 41.4 44.8 \\(10 ^ {-10}\\) 46.1 49.5"},{"location":"localization/autoware_ekf_localizer/#kalman-filter-model","title":"Kalman Filter Model","text":""},{"location":"localization/autoware_ekf_localizer/#kinematics-model-in-update-function","title":"kinematics model in update function","text":"<p>where, \\(\\theta_k\\) represents the vehicle's heading angle, including the mounting angle bias. \\(b_k\\) is a correction term for the yaw bias, and it is modeled so that \\((\\theta_k+b_k)\\) becomes the heading angle of the base_link. The pose_estimator is expected to publish the base_link in the map coordinate system. However, the yaw angle may be offset due to calibration errors. This model compensates this error and improves estimation accuracy.</p>"},{"location":"localization/autoware_ekf_localizer/#time-delay-model","title":"time delay model","text":"<p>The measurement time delay is handled by an augmented state [1] (See, Section 7.3 FIXED-LAG SMOOTHING).</p> <p></p> <p>Note that, although the dimension gets larger since the analytical expansion can be applied based on the specific structures of the augmented states, the computational complexity does not significantly change.</p>"},{"location":"localization/autoware_ekf_localizer/#test-result-with-autoware-ndt","title":"Test Result with Autoware NDT","text":""},{"location":"localization/autoware_ekf_localizer/#diagnostics","title":"Diagnostics","text":""},{"location":"localization/autoware_ekf_localizer/#the-conditions-that-result-in-a-warn-state","title":"The conditions that result in a WARN state","text":"<ul> <li>The node is not in the activate state.</li> <li>The initial pose is not set.</li> <li>The number of consecutive no measurement update via the Pose/Twist topic exceeds the <code>pose_no_update_count_threshold_warn</code>/<code>twist_no_update_count_threshold_warn</code>.</li> <li>The timestamp of the Pose/Twist topic is beyond the delay compensation range.</li> <li>The Pose/Twist topic is beyond the range of Mahalanobis distance for covariance estimation.</li> <li>The covariance ellipse is bigger than threshold <code>warn_ellipse_size</code> for long axis or <code>warn_ellipse_size_lateral_direction</code> for lateral_direction.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#the-conditions-that-result-in-an-error-state","title":"The conditions that result in an ERROR state","text":"<ul> <li>The number of consecutive no measurement update via the Pose/Twist topic exceeds the <code>pose_no_update_count_threshold_error</code>/<code>twist_no_update_count_threshold_error</code>.</li> <li>The covariance ellipse is bigger than threshold <code>error_ellipse_size</code> for long axis or <code>error_ellipse_size_lateral_direction</code> for lateral_direction.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#known-issues","title":"Known issues","text":"<ul> <li>If multiple pose_estimators are used, the input to the EKF will include multiple yaw biases corresponding to each source. However, the current EKF assumes the existence of only one yaw bias. Therefore, yaw bias <code>b_k</code> in the current EKF state would not make any sense and cannot correctly handle these multiple yaw biases. Thus, future work includes introducing yaw bias for each sensor with yaw estimation.</li> </ul>"},{"location":"localization/autoware_ekf_localizer/#reference","title":"reference","text":"<p>[1] Anderson, B. D. O., &amp; Moore, J. B. (1979). Optimal filtering. Englewood Cliffs, NJ: Prentice-Hall.</p>"},{"location":"localization/autoware_localization_util/","title":"autoware_localization_util","text":""},{"location":"localization/autoware_localization_util/#autoware_localization_util","title":"autoware_localization_util","text":""},{"location":"localization/autoware_localization_util/#overview","title":"Overview","text":"<p><code>autoware_localization_util</code> is a collection of localization utility packages. It contains 5 individual library that used by autoware localization nodes.</p> <ul> <li><code>covariance_ellipse</code> 2d covariance visualization wrapper.</li> <li><code>smart_pose_buffer</code> pose buffer management library which contains interpolate and data validation.</li> <li><code>tree_structured_parzen_estimator</code> A Tree Structured Parzen Estimator library.</li> <li><code>util_func</code> A tool library which contains several function for localization nodes.</li> </ul>"},{"location":"localization/autoware_localization_util/#design","title":"Design","text":"<ul> <li><code>covariance_ellipse</code> Translate <code>geometry_msgs::msg::PoseWithCovariance</code> message into ellipse visual marker to demonstrate covariance distribution.</li> <li><code>smart_pose_buffer</code> A buffer library which implements pose message buffering, pose interpolate and pose validation.</li> <li><code>tree_structured_parzen_estimator</code> A Probability Estimator library that includes estimator and log likelihood ratio calculation.</li> <li><code>util_func</code> Tool function collection.</li> </ul>"},{"location":"localization/autoware_localization_util/#usage","title":"Usage","text":""},{"location":"localization/autoware_localization_util/#covariance_ellipse","title":"covariance_ellipse","text":"<p>Include header file to use:</p> <pre><code>#include \"autoware/localization_util/covariance_ellipse.hpp\"\n</code></pre> <p>calculate ellipse and visualize</p> <pre><code>autoware::localization_util::Ellipse ellipse_ = autoware::localization_util::calculate_xy_ellipse(input_msg-&gt;pose, scale_);\n\nconst auto ellipse_marker = autoware::localization_util::create_ellipse_marker(\nellipse_, input_msg-&gt;header, input_msg-&gt;pose);\n</code></pre>"},{"location":"localization/autoware_localization_util/#smart_pose_buffer","title":"smart_pose_buffer","text":"<p>buffer init</p> <pre><code>#include \"autoware/localization_util/smart_pose_buffer.hpp\"\n\nusing autoware::localization_util::SmartPoseBuffer;\n\nstd::unique_ptr&lt;autoware::localization_util::SmartPoseBuffer&gt; initial_pose_buffer_;\ninitial_pose_buffer_ = std::make_unique&lt;SmartPoseBuffer&gt;(\nthis-&gt;get_logger(), param_.validation.initial_pose_timeout_sec,\nparam_.validation.initial_pose_distance_tolerance_m);\n</code></pre> <p>interpolate and pop out old pose message</p> <pre><code>std::optional&lt;SmartPoseBuffer::InterpolateResult&gt; interpolation_result_opt =\ninitial_pose_buffer_-&gt;interpolate(sensor_ros_time);\n\n...\n\ninitial_pose_buffer_-&gt;pop_old(sensor_ros_time);\nconst SmartPoseBuffer::InterpolateResult &amp; interpolation_result =\ninterpolation_result_opt.value();\n</code></pre> <p>clear buffer</p> <pre><code>initial_pose_buffer_-&gt;clear();\n</code></pre>"},{"location":"localization/autoware_localization_util/#tree_structured_parzen_estimator","title":"tree_structured_parzen_estimator","text":"<p>init the estimator. n_startup_trials -- The number of initial random trials in the TPE (Tree-Structured Parzen Estimator). This value should be equal to or less than 'initial_estimate_particles_num' and more than 0. If it is equal to 'initial_estimate_particles_num', the search will be the same as a full random search.</p> <pre><code>#include \"autoware/localization_util/tree_structured_parzen_estimator.hpp\"\n\nusing autoware::localization_util::TreeStructuredParzenEstimator;\n\nTreeStructuredParzenEstimator tpe(\nTreeStructuredParzenEstimator::Direction::MAXIMIZE,\nparam_.initial_pose_estimation.n_startup_trials, sample_mean, sample_stddev);\n</code></pre> <p>get estimation result</p> <pre><code>const TreeStructuredParzenEstimator::Input input = tpe.get_next_input();\n</code></pre> <p>add new data to the estimator</p> <pre><code>TreeStructuredParzenEstimator::Input result(6);\nresult[0] = pose.position.x;\nresult[1] = pose.position.y;\nresult[2] = pose.position.z;\nresult[3] = rpy.x;\nresult[4] = rpy.y;\nresult[5] = rpy.z;\ntpe.add_trial(TreeStructuredParzenEstimator::Trial{result, ndt_result.transform_probability});\n</code></pre>"},{"location":"localization/autoware_localization_util/#util_func","title":"util_func","text":"<p>include header file to use</p> <pre><code>#include \"autoware/localization_util/util_func.hpp\"\n\nusing autoware::localization_util::exchange_color_crc;\nusing autoware::localization_util::matrix4f_to_pose;\nusing autoware::localization_util::point_to_vector3d;\nusing autoware::localization_util::pose_to_matrix4f;\n</code></pre> <p>list of useful function</p> <pre><code>std_msgs::msg::ColorRGBA exchange_color_crc(double x);\ndouble calc_diff_for_radian(const double lhs_rad, const double rhs_rad);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::Pose &amp; pose);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::PoseStamped &amp; pose);\ngeometry_msgs::msg::Vector3 get_rpy(const geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose);\ngeometry_msgs::msg::Quaternion rpy_rad_to_quaternion(\nconst double r_rad, const double p_rad, const double y_rad);\ngeometry_msgs::msg::Quaternion rpy_deg_to_quaternion(\nconst double r_deg, const double p_deg, const double y_deg);\ngeometry_msgs::msg::Twist calc_twist(\nconst geometry_msgs::msg::PoseStamped &amp; pose_a, const geometry_msgs::msg::PoseStamped &amp; pose_b);\ngeometry_msgs::msg::PoseStamped interpolate_pose(\nconst geometry_msgs::msg::PoseStamped &amp; pose_a, const geometry_msgs::msg::PoseStamped &amp; pose_b,\nconst rclcpp::Time &amp; time_stamp);\ngeometry_msgs::msg::PoseStamped interpolate_pose(\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_a,\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_b, const rclcpp::Time &amp; time_stamp);\nEigen::Affine3d pose_to_affine3d(const geometry_msgs::msg::Pose &amp; ros_pose);\nEigen::Matrix4f pose_to_matrix4f(const geometry_msgs::msg::Pose &amp; ros_pose);\ngeometry_msgs::msg::Pose matrix4f_to_pose(const Eigen::Matrix4f &amp; eigen_pose_matrix);\nEigen::Vector3d point_to_vector3d(const geometry_msgs::msg::Point &amp; ros_pos);\ntemplate &lt;class T&gt;\nT transform(const T &amp; input, const geometry_msgs::msg::TransformStamped &amp; transform);double norm(const geometry_msgs::msg::Point &amp; p1, const geometry_msgs::msg::Point &amp; p2);\n\nvoid output_pose_with_cov_to_log(\nconst rclcpp::Logger &amp; logger, const std::string &amp; prefix,\nconst geometry_msgs::msg::PoseWithCovarianceStamped &amp; pose_with_cov);\n</code></pre>"},{"location":"planning/autoware_objects_of_interest_marker_interface/","title":"Objects Of Interest Marker Interface","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#objects-of-interest-marker-interface","title":"Objects Of Interest Marker Interface","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#overview","title":"Overview","text":"<p><code>autoware_objects_of_interest_marker_interface</code> is a collection of object visualization function packages.</p>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#design","title":"Design","text":"<p>This package implement a library to manage and visualize the object information by construct and publish it as marker array to rviz.</p> <p>For a object to be visualized, it has three import characteristics.</p> <ul> <li>pose the position of the object</li> <li>shape the shape of the Bounding box of the object</li> <li>color the color of the Bounding box of the object</li> </ul>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#usage","title":"Usage","text":""},{"location":"planning/autoware_objects_of_interest_marker_interface/#init","title":"init","text":"<p>include the header file to use then init the library</p> <pre><code>#include &lt;autoware/objects_of_interest_marker_interface/objects_of_interest_marker_interface.hpp&gt;\n\nautoware::objects_of_interest_marker_interface::ObjectsOfInterestMarkerInterface\nobjects_of_interest_marker_interface_{this, \"obstacle_cruise_planner\"};\n</code></pre>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#insert","title":"insert","text":"<p>insert object information to the 'objects_of_interest_marker_interface' manager</p> <pre><code>using autoware::objects_of_interest_marker_interface::ColorName;\nobjects_of_interest_marker_interface_.insertObjectData(\nstopped_obstacle.pose, stopped_obstacle.shape, ColorName::RED);\n</code></pre>"},{"location":"planning/autoware_objects_of_interest_marker_interface/#publish","title":"publish","text":"<p>publish object information to the rviz to visualize</p> <pre><code>objects_of_interest_marker_interface_.publishMarkerArray();\n</code></pre>"},{"location":"planning/autoware_path_generator/","title":"Path Generator","text":""},{"location":"planning/autoware_path_generator/#path-generator","title":"Path Generator","text":"<p>The <code>path_generator</code> node receives a route from <code>mission_planner</code> and converts the center line into a path. If the route has waypoints set, it generates a path passing through them.</p> <p>This package is a simple alternative of <code>behavior_path_generator</code>.</p>"},{"location":"planning/autoware_path_generator/#path-generation","title":"Path generation","text":"<p>When input data is ready, it first searches for the lanelet closest to the vehicle. If found, it gets the lanelets within a distance of <code>backward_path_length</code> behind and <code>forward_path_length</code> in front. Their center lines are concatenated to generate a path.</p> <p>If waypoints exist in the route, it replaces the overlapped segment of the center line with them. The overlap interval is determined as shown in the following figure.</p> <p></p>"},{"location":"planning/autoware_path_generator/#flowchart","title":"Flowchart","text":""},{"location":"planning/autoware_path_generator/#input-topics","title":"Input topics","text":"Name Type Description <code>~/input/odometry</code> <code>nav_msgs::msg::Odometry</code> ego pose <code>~/input/vector_map</code> <code>autoware_map_msgs::msg::LaneletMapBin</code> vector map information <code>~/input/route</code> <code>autoware_planning_msgs::msg::LaneletRoute</code> current route from start to goal"},{"location":"planning/autoware_path_generator/#output-topics","title":"Output topics","text":"Name Type Description QoS Durability <code>~/output/path</code> <code>autoware_internal_planning_msgs::msg::PathWithLaneId</code> generated path <code>volatile</code>"},{"location":"planning/autoware_path_generator/#parameters","title":"Parameters","text":"Name Type Description Default Range planning_hz float Planning frequency [Hz] 10 \u22650.0 backward_path_length float Length of generated path behind vehicle [m] 5 \u22650.0 forward_path_length float Length of generated path in front of vehicle [m] 300 \u22650.0 waypoint_group_separation_threshold float Maximum distance at which consecutive waypoints are considered to belong to the same group [m] 1 \u22650.0 waypoint_group_interval_margin_ratio float Ratio for determining length of switching section from centerline to waypoints 10 \u22650.0"},{"location":"planning/autoware_planning_factor_interface/","title":"autoware_planning_factor_interface","text":""},{"location":"planning/autoware_planning_factor_interface/#autoware_planning_factor_interface","title":"autoware_planning_factor_interface","text":""},{"location":"planning/autoware_planning_factor_interface/#overview","title":"Overview","text":"<p>The <code>PlanningFactorInterface</code> is a C++ class designed to facilitate the addition and publication of planning factors.</p>"},{"location":"planning/autoware_planning_factor_interface/#design","title":"Design","text":"<p>The <code>PlanningFactorInterface</code> class is designed to be lightweight and efficient, with the following key components:</p> <ul> <li>Add: Methods to add planning factors to the interface.</li> </ul> <ul> <li>Publisher: The class includes a publisher for <code>PlanningFactorArray</code> messages, which are used to distribute planning factors to other nodes in the system.</li> </ul> <p>The design emphasizes flexibility and ease of use, allowing developers to quickly integrate new planning factors into autoware.</p>"},{"location":"planning/autoware_planning_factor_interface/#usage","title":"Usage","text":""},{"location":"planning/autoware_planning_factor_interface/#including-the-header","title":"Including the Header","text":"<p>To use the <code>PlanningFactorInterface</code>, include the header file in your code:</p> <pre><code>#include &lt;autoware/planning_factor_interface/planning_factor_interface.hpp&gt;\n</code></pre>"},{"location":"planning/autoware_planning_factor_interface/#creating-an-instance","title":"Creating an Instance","text":"<p>Instantiate the <code>PlanningFactorInterface</code> by providing a node and a name for the factor module:</p> <pre><code>class PlannerInterface\n{\npublic:\nvirtual ~PlannerInterface() = default;\nPlannerInterface(\nrclcpp::Node &amp; node, const LongitudinalInfo &amp; longitudinal_info,\nconst autoware::vehicle_info_utils::VehicleInfo &amp; vehicle_info,\nconst EgoNearestParam &amp; ego_nearest_param, const std::shared_ptr&lt;DebugData&gt; debug_data_ptr)\n: planning_factor_interface_{std::make_unique&lt;\nautoware::planning_factor_interface::PlanningFactorInterface&gt;(\n&amp;node, \"obstacle_cruise_planner\")},\n</code></pre> <p>code example from src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/include/autoware/obstacle_cruise_planner/planner_interface.hpp</p>"},{"location":"planning/autoware_planning_factor_interface/#adding-planning-factors","title":"Adding Planning Factors","text":"<p>The <code>add</code> method can be used to add planning factors. Here's an example from src/universe/autoware.universe/planning/autoware_obstacle_cruise_planner/src/pid_based_planner/pid_based_planner.cpp.</p> <pre><code>planning_factor_interface_-&gt;add(\nstop_traj_points, planner_data.ego_pose, stop_traj_points.at(wall_idx).pose,\nautoware_internal_planning_msgs::msg::PlanningFactor::NONE,\nautoware_internal_planning_msgs::msg::SafetyFactorArray{});\n</code></pre>"},{"location":"planning/autoware_planning_factor_interface/#publishing-factors","title":"Publishing Factors","text":"<p>After adding planning factors, you can publish them by calling the <code>publish</code> method:</p> <pre><code>// Publish the added factors\nplanning_factor_interface_-&gt;publish();\n</code></pre>"},{"location":"planning/autoware_route_handler/","title":"route handler","text":""},{"location":"planning/autoware_route_handler/#route-handler","title":"route handler","text":"<p><code>route_handler</code> is a library for calculating driving route on the lanelet map.</p>"},{"location":"planning/autoware_route_handler/#unit-testing","title":"Unit Testing","text":"<p>The unit testing depends on <code>autoware_test_utils</code> package. <code>autoware_test_utils</code> is a library that provides several common functions to simplify unit test creating.</p> <p></p> <p>By default, route file is necessary to create tests. The following illustrates the route that are used in the unit test</p>"},{"location":"planning/autoware_route_handler/#lane-change-test-route","title":"Lane change test route","text":"<ul> <li>The route is based on map that can be obtained from <code>autoware_test_utils\\test_map</code></li> </ul>"},{"location":"sensing/autoware_gnss_poser/","title":"gnss_poser","text":""},{"location":"sensing/autoware_gnss_poser/#gnss_poser","title":"gnss_poser","text":""},{"location":"sensing/autoware_gnss_poser/#overview","title":"Overview","text":"<p>The <code>gnss_poser</code> is a node that subscribes gnss sensing messages and calculates vehicle pose with covariance.</p>"},{"location":"sensing/autoware_gnss_poser/#design","title":"Design","text":"<p>This node subscribes to NavSatFix to publish the pose of base_link. The data in NavSatFix represents the antenna's position. Therefore, it performs a coordinate transformation using the tf from <code>base_link</code> to the antenna's position. The frame_id of the antenna's position refers to NavSatFix's <code>header.frame_id</code>. (Note that <code>header.frame_id</code> in NavSatFix indicates the antenna's frame_id, not the Earth or reference ellipsoid. See also NavSatFix definition.)</p> <p>If the transformation from <code>base_link</code> to the antenna cannot be obtained, it outputs the pose of the antenna position without performing coordinate transformation.</p>"},{"location":"sensing/autoware_gnss_poser/#inputs-outputs","title":"Inputs / Outputs","text":""},{"location":"sensing/autoware_gnss_poser/#input","title":"Input","text":"Name Type Description <code>/map/map_projector_info</code> <code>autoware_map_msgs::msg::MapProjectorInfo</code> map projection info <code>~/input/fix</code> <code>sensor_msgs::msg::NavSatFix</code> gnss status message <code>~/input/autoware_orientation</code> <code>autoware_sensing_msgs::msg::GnssInsOrientationStamped</code> orientation click here for more details"},{"location":"sensing/autoware_gnss_poser/#output","title":"Output","text":"Name Type Description <code>~/output/pose</code> <code>geometry_msgs::msg::PoseStamped</code> vehicle pose calculated from gnss sensing data <code>~/output/gnss_pose_cov</code> <code>geometry_msgs::msg::PoseWithCovarianceStamped</code> vehicle pose with covariance calculated from gnss sensing data <code>~/output/gnss_fixed</code> <code>autoware_internal_debug_msgs::msg::BoolStamped</code> gnss fix status"},{"location":"sensing/autoware_gnss_poser/#parameters","title":"Parameters","text":"<p>Parameters in below table</p> Name Type Default Description <code>base_frame</code> <code>string</code> <code>base_link</code> frame id for base_frame <code>gnss_base_frame</code> <code>string</code> <code>gnss_base_link</code> frame id for gnss_base_frame <code>map_frame</code> <code>string</code> <code>map</code> frame id for map_frame <code>use_gnss_ins_orientation</code> <code>boolean</code> <code>true</code> use Gnss-Ins orientation <code>gnss_pose_pub_method</code> <code>integer</code> <code>0</code> 0: Instant Value 1: Average Value 2: Median Value. If <code>buffer_epoch</code> is set to 0, <code>gnss_pose_pub_method</code> loses affect. Range: 0~2. <code>buff_epoch</code> <code>integer</code> <code>1</code> Buffer epoch. Range: 0~inf. <p>All above parameters can be changed in config file gnss_poser.param.yaml .</p>"},{"location":"testing/autoware_planning_test_manager/","title":"Autoware Planning Test Manager","text":""},{"location":"testing/autoware_planning_test_manager/#autoware-planning-test-manager","title":"Autoware Planning Test Manager","text":""},{"location":"testing/autoware_planning_test_manager/#background","title":"Background","text":"<p>In each node of the planning module, when exceptional input, such as unusual routes or significantly deviated ego-position, is given, the node may not be prepared for such input and could crash. As a result, debugging node crashes can be time-consuming. For example, if an empty trajectory is given as input and it was not anticipated during implementation, the node might crash due to the unaddressed exceptional input when changes are merged, during scenario testing or while the system is running on an actual vehicle.</p>"},{"location":"testing/autoware_planning_test_manager/#purpose","title":"Purpose","text":"<p>The purpose is to provide a utility for implementing tests to ensure that node operates correctly when receiving exceptional input. By utilizing this utility and implementing tests for exceptional input, the purpose is to reduce bugs that are only discovered when actually running the system, by requiring measures for exceptional input before merging PRs.</p>"},{"location":"testing/autoware_planning_test_manager/#features","title":"Features","text":""},{"location":"testing/autoware_planning_test_manager/#confirmation-of-normal-operation","title":"Confirmation of normal operation","text":"<p>For the test target node, confirm that the node operates correctly and publishes the required messages for subsequent nodes. To do this, test_node publish the necessary messages and confirm that the node's output is being published.</p>"},{"location":"testing/autoware_planning_test_manager/#robustness-confirmation-for-special-inputs","title":"Robustness confirmation for special inputs","text":"<p>After confirming normal operation, ensure that the test target node does not crash when given exceptional input. To do this, provide exceptional input from the test_node and confirm that the node does not crash.</p> <p>(WIP)</p>"},{"location":"testing/autoware_planning_test_manager/#usage","title":"Usage","text":"<pre><code>TEST(PlanningModuleInterfaceTest, NodeTestWithExceptionTrajectory)\n{\nrclcpp::init(0, nullptr);\n\n// instantiate test_manager with PlanningInterfaceTestManager type\nauto test_manager = std::make_shared&lt;autoware::planning_test_manager::PlanningInterfaceTestManager&gt;();\n\n// get package directories for necessary configuration files\nconst auto autoware_test_utils_dir =\nament_index_cpp::get_package_share_directory(\"autoware_test_utils\");\nconst auto target_node_dir =\nament_index_cpp::get_package_share_directory(\"target_node\");\n\n// set arguments to get the config file\nnode_options.arguments(\n{\"--ros-args\", \"--params-file\",\nautoware_test_utils_dir + \"/config/test_vehicle_info.param.yaml\", \"--params-file\",\nautoware_planning_validator_dir + \"/config/planning_validator.param.yaml\"});\n\n// instantiate the TargetNode with node_options\nauto test_target_node = std::make_shared&lt;TargetNode&gt;(node_options);\n\n// publish the necessary topics from test_manager second argument is topic name\ntest_manager-&gt;publishOdometry(test_target_node, \"/localization/kinematic_state\");\ntest_manager-&gt;publishMaxVelocity(\ntest_target_node, \"velocity_smoother/input/external_velocity_limit_mps\");\n\n// set scenario_selector's input topic name(this topic is changed to test node)\ntest_manager-&gt;setTrajectoryInputTopicName(\"input/parking/trajectory\");\n\n// test with normal trajectory\nASSERT_NO_THROW(test_manager-&gt;testWithNominalTrajectory(test_target_node));\n\n// make sure target_node is running\nEXPECT_GE(test_manager-&gt;getReceivedTopicNum(), 1);\n\n// test with trajectory input with empty/one point/overlapping point\nASSERT_NO_THROW(test_manager-&gt;testWithAbnormalTrajectory(test_target_node));\n\n// shutdown ROS context\nrclcpp::shutdown();\n}\n</code></pre>"},{"location":"testing/autoware_planning_test_manager/#implemented-tests","title":"Implemented tests","text":"Node Test name exceptional input output Exceptional input pattern autoware_planning_validator NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points velocity_smoother NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_cruise_planner NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_stop_planner NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points obstacle_velocity_limiter NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points path_optimizer NodeTestWithExceptionTrajectory trajectory trajectory Empty, single point, path with duplicate points scenario_selector NodeTestWithExceptionTrajectoryLaneDrivingMode NodeTestWithExceptionTrajectoryParkingMode trajectory scenario Empty, single point, path with duplicate points for scenarios:LANEDRIVING and PARKING freespace_planner NodeTestWithExceptionRoute route trajectory Empty route behavior_path_planner NodeTestWithExceptionRoute NodeTestWithOffTrackEgoPose route route odometry Empty route Off-lane ego-position behavior_velocity_planner NodeTestWithExceptionPathWithLaneID path_with_lane_id path Empty path"},{"location":"testing/autoware_planning_test_manager/#important-notes","title":"Important Notes","text":"<p>During test execution, when launching a node, parameters are loaded from the parameter file within each package. Therefore, when adding parameters, it is necessary to add the required parameters to the parameter file in the target node package. This is to prevent the node from being unable to launch if there are missing parameters when retrieving them from the parameter file during node launch.</p>"},{"location":"testing/autoware_planning_test_manager/#future-extensions-unimplemented-parts","title":"Future extensions / Unimplemented parts","text":"<p>(WIP)</p>"},{"location":"testing/autoware_pyplot/","title":"autoware_pyplot","text":""},{"location":"testing/autoware_pyplot/#autoware_pyplot","title":"autoware_pyplot","text":"<p>This package provides C++ interface for the notable <code>matplotlib</code> using <code>pybind11</code> backend for</p> <ul> <li>creating scientific plots and images illustrating the function inputs/outputs</li> <li>debugging the output and internal data of a function before unit testing in a more lightweight manner than planning_simulator</li> </ul>"},{"location":"testing/autoware_pyplot/#usage","title":"usage","text":"<p>In your main function, setup the python context and import <code>matplotlib</code></p> <pre><code>#include &lt;autoware/pyplot/pyplot.hpp&gt;\n#include &lt;pybind11/embed.h&gt;\n\n// in main...\npy::scoped_interpreter guard{};\nauto plt = autoware::pyplot::import();\n</code></pre> <p>Then you can use major functionalities of <code>matplotlib</code> almost in the same way as native python code.</p> <pre><code>{\nplt.plot(Args(std::vector&lt;int&gt;({1, 3, 2, 4})), Kwargs(\"color\"_a = \"blue\", \"linewidth\"_a = 1.0));\nplt.xlabel(Args(\"x-title\"));\nplt.ylabel(Args(\"y-title\"));\nplt.title(Args(\"title\"));\nplt.xlim(Args(0, 5));\nplt.ylim(Args(0, 5));\nplt.grid(Args(true));\nplt.savefig(Args(\"test_single_plot.png\"));\n}\n\n{\nauto [fig, axes] = plt.subplots(1, 2);\nauto &amp; ax1 = axes[0];\nauto &amp; ax2 = axes[1];\n\nax1.set_aspect(Args(\"equal\"));\nax2.set_aspect(Args(\"equal\"));\n}\n</code></pre>"},{"location":"testing/autoware_test_utils/","title":"Test Utils","text":""},{"location":"testing/autoware_test_utils/#test-utils","title":"Test Utils","text":""},{"location":"testing/autoware_test_utils/#background","title":"Background","text":"<p>Several Autoware's components and modules have already adopted unit testing, so a common library to ease the process of writing unit tests is necessary.</p>"},{"location":"testing/autoware_test_utils/#purpose","title":"Purpose","text":"<p>The objective of the <code>test_utils</code> is to develop a unit testing library for the Autoware components. This library will include</p> <ul> <li>commonly used functions</li> <li>input/mock data parser</li> <li>maps for testing</li> <li>common routes and mock data for testing.</li> </ul>"},{"location":"testing/autoware_test_utils/#available-maps","title":"Available Maps","text":"<p>The following maps are available here</p>"},{"location":"testing/autoware_test_utils/#common","title":"Common","text":"<p>The common map contains multiple types of usable inputs, including shoulder lanes, intersections, and some regulatory elements. The common map is named <code>lanelet2_map.osm</code> in the folder.</p> <p></p>"},{"location":"testing/autoware_test_utils/#2-km-straight","title":"2 km Straight","text":"<p>The 2 km straight lanelet map consists of two lanes that run in the same direction. The map is named <code>2km_test.osm</code>.</p> <p></p> <p>The following illustrates the design of the map.</p> <p></p>"},{"location":"testing/autoware_test_utils/#road_shoulders","title":"road_shoulders","text":"<p>The road_shoulders lanelet map consist of a variety of pick-up/drop-off site maps with road_shoulder tags including:</p> <ul> <li>pick-up/drop-off sites on the side of street lanes</li> <li>pick-up/drop-off sites on the side of curved lanes</li> <li>pick-up/drop-off sites inside a private area</li> </ul> <p></p> <p>You can easily launch planning_simulator by</p> <pre><code>ros2 launch autoware_test_utils psim_road_shoulder.launch.xml vehicle_model:=&lt;&gt; sensor_model:=&lt;&gt; use_sim_time:=true\n</code></pre>"},{"location":"testing/autoware_test_utils/#intersection","title":"intersection","text":"<p>The intersections lanelet map consist of a variety of intersections including:</p> <ul> <li>4-way crossing with traffic light</li> <li>4-way crossing without traffic light</li> <li>T-shape crossing without traffic light</li> <li>intersection with a loop</li> <li>complicated intersection</li> </ul> <p></p> <p>You can easily launch planning_simulator by</p> <pre><code>ros2 launch autoware_test_utils psim_intersection.launch.xml vehicle_model:=&lt;&gt; sensor_model:=&lt;&gt; use_sim_time:=true\n</code></pre>"},{"location":"testing/autoware_test_utils/#example-use-cases","title":"Example use cases","text":""},{"location":"testing/autoware_test_utils/#autoware-planning-test-manager","title":"Autoware Planning Test Manager","text":"<p>The goal of the Autoware Planning Test Manager is to test planning module nodes. The <code>PlanningInterfaceTestManager</code> class (source code) creates wrapper functions based on the <code>test_utils</code> functions.</p>"},{"location":"testing/autoware_test_utils/#generate-test-data-for-unit-testing","title":"Generate test data for unit testing","text":"<p>As presented in this PR description, the user can save a snapshot of the scene to a yaml file while running Planning Simulation on the test map.</p> <pre><code>ros2 launch autoware_test_utils psim_road_shoulder.launch.xml\nros2 launch autoware_test_utils psim_intersection.launch.xml\n</code></pre> <p>It uses the autoware <code>sample_vehicle_description</code> and <code>sample_sensor_kit</code> by default, and <code>autoware_test_utils/config/test_vehicle_info.param.yaml</code> is exactly the same as that of <code>sample_vehicle_description</code>. If specified, <code>vehicle_model</code>/<code>sensor_model</code> argument is available.</p> <pre><code>ros2 service call /autoware_test_utils/topic_snapshot_saver std_srvs/srv/Empty \\{\\}\n</code></pre> <p>The list and field names of the topics to be saved are specified in <code>config/sample_topic_snapshot.yaml</code>.</p> <pre><code># setting\nfields:\n- name: self_odometry # this is the field name for this topic\ntype: Odometry # the abbreviated type name of this topic\ntopic: /localization/kinematic_state # the name of this topic\n\n# output\nself_odometry:\n- header: ...\n...\n</code></pre> <p>Each field can be parsed to ROS message type using the functions defined in <code>autoware_test_utils/mock_data_parser.hpp</code></p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/","title":"autoware_testing","text":""},{"location":"testing/autoware_testing/design/autoware_testing-design/#autoware_testing","title":"autoware_testing","text":"<p>This is the design document for the <code>autoware_testing</code> package.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#purpose-use-cases","title":"Purpose / Use cases","text":"<p>The package aims to provide a unified way to add standard testing functionality to the package, currently supporting:</p> <ul> <li>Smoke testing (<code>add_smoke_test</code>): launch a node with default configuration and ensure that it starts up and does not crash.</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#design","title":"Design","text":"<p>Uses <code>ros_testing</code> (which is an extension of <code>launch_testing</code>) and provides some parametrized, reusable standard tests to run.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#assumptions-known-limits","title":"Assumptions / Known limits","text":"<p>Parametrization is limited to package, executable names, parameters filename and executable arguments. Test namespace is set as 'test'. Parameters file for the package is expected to be in <code>param</code> directory inside package.</p>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#inputs-outputs-api","title":"Inputs / Outputs / API","text":"<p>To add a smoke test to your package tests, add test dependency on <code>autoware_testing</code> to <code>package.xml</code></p> <pre><code>&lt;test_depend&gt;autoware_testing&lt;/test_depend&gt;\n</code></pre> <p>and add the following two lines to <code>CMakeLists.txt</code> in the <code>IF (BUILD_TESTING)</code> section:</p> <pre><code>find_package(autoware_testing REQUIRED)\nadd_smoke_test(&lt;package_name&gt; &lt;executable_name&gt; [PARAM_FILENAME &lt;param_filename&gt;] [EXECUTABLE_ARGUMENTS &lt;arguments&gt;])\n</code></pre> <p>Where</p> <p><code>&lt;package_name&gt;</code> - [required] tested node package name.</p> <p><code>&lt;executable_name&gt;</code> - [required] tested node executable name.</p> <p><code>&lt;param_filename&gt;</code> - [optional] param filename. Default value is <code>test.param.yaml</code>. Required mostly in situation where there are multiple smoke tests in a package and each requires different parameters set</p> <p><code>&lt;arguments&gt;</code> - [optional] arguments passed to executable. By default no arguments are passed.</p> <p>which adds <code>&lt;executable_name&gt;_smoke_test</code> test to suite.</p> <p>Example test result:</p> <pre><code>build/&lt;package_name&gt;/test_results/&lt;package_name&gt;/&lt;executable_name&gt;_smoke_test.xunit.xml: 1 test, 0 errors, 0 failures, 0 skipped\n</code></pre>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#references-external-links","title":"References / External links","text":"<ul> <li>https://en.wikipedia.org/wiki/Smoke_testing_(software)</li> <li>https://github.com/ros2/ros_testing</li> <li>https://github.com/ros2/launch/blob/master/launch_testing</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#future-extensions-unimplemented-parts","title":"Future extensions / Unimplemented parts","text":"<ul> <li>Adding more types of standard tests.</li> </ul>"},{"location":"testing/autoware_testing/design/autoware_testing-design/#related-issues","title":"Related issues","text":"<ul> <li>Issue #700: add smoke test</li> <li>Issue #1224: Port other packages with smoke tests to use <code>autoware_testing</code></li> </ul>"}]}